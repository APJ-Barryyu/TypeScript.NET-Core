{"version":3,"sources":["System/Collections/MapUtility.ts"],"names":[],"mappings":"AAAA;;;GAGG;;;;IAIH;;;;;OAKG;IACH,eACC,MAAQ,EACR,MAAQ;QAER,IAAM,MAAM,GAAO,MAAM,IAAI,EAAE,CAAC;QAChC,KAAI,IAAM,GAAG,IAAI,MAAM,EACvB;YACC,IAAG,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,EAC7B;gBACC,MAAM,CAAC,GAAG,CAAC,GAAS,MAAO,CAAC,GAAG,CAAC,CAAC;aACjC;SACD;QACD,OAAO,MAAM,CAAC;IACf,CAAC;;IAED;;;;;OAKG;IACH,gBACC,MAAQ,EACR,QAAU;QAEV,IAAM,MAAM,GAAO,MAAM,IAAI,EAAE,CAAC;QAChC,KAAI,IAAM,GAAG,IAAI,QAAQ,EACzB;YACC,IAAG,QAAQ,CAAC,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,EAC9D;gBACC,MAAM,CAAC,GAAG,CAAC,GAAS,QAAS,CAAC,GAAG,CAAC,CAAC;aACnC;SACD;QACD,OAAO,MAAM,CAAC;IACf,CAAC;;IAED;;;;OAIG;IACH,cAA0C,MAAQ;QAEjD,OAAO,KAAK,CAAC,EAAE,EAAE,MAAM,CAAC,CAAC;IAC1B,CAAC;;IAGD;;;;;OAKG;IACH,eACC,CAAG,EACH,CAAG;QAEH,OAAO,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAC1B,CAAC;;IAED;;;;OAIG;IACH,cAAgD,MAAgB,EAAE,MAAc;QAE/E,KAAI,IAAM,GAAG,IAAI,MAAM,EACvB;YACC,IAAG,CAAC,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,EAC9B;gBACC,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC;aACnB;SACD;QACD,qBAAqB;IACtB,CAAC;;IAED,cAAqB,GAAa,EAAE,KAAgB;QAAhB,sBAAA,EAAA,SAAgB;QAEnD,IAAG,GAAG,IAAI,KAAK,EACf;YACC,KAAe,UAAgB,EAAhB,KAAA,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,EAAhB,cAAgB,EAAhB,IAAgB,EAC/B;gBADI,IAAI,GAAG,SAAA;gBAEV,IAAM,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;gBACnB,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC;gBAChB,IAAI,CAAC,CAAC,EAAE,KAAK,GAAG,CAAC,CAAC,CAAC;aACnB;SACD;IACF,CAAC;;;;8BArGD;;;eAGG;QAkGF,CAAC","file":"MapUtility.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {IMap} from \"../../IMap\";\r\n\r\n/**\r\n * Takes a target object and applies all source values to it.\r\n * @param target\r\n * @param source\r\n * @returns {any}\r\n */\r\nexport function apply<T extends IMap<any>, U extends IMap<any>>(\r\n\ttarget:T,\r\n\tsource:U):T & U\r\n{\r\n\tconst result:any = target || {};\r\n\tfor(const key in source)\r\n\t{\r\n\t\tif(source.hasOwnProperty(key))\r\n\t\t{\r\n\t\t\tresult[key] = (<any>source)[key];\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Takes a target object and ensures values exist.\r\n * @param target\r\n * @param defaults\r\n * @returns {any}\r\n */\r\nexport function ensure<T extends IMap<any>, U extends IMap<any>>(\r\n\ttarget:T,\r\n\tdefaults:U):T & U\r\n{\r\n\tconst result:any = target || {};\r\n\tfor(const key in defaults)\r\n\t{\r\n\t\tif(defaults.hasOwnProperty(key) && !result.hasOwnProperty(key))\r\n\t\t{\r\n\t\t\tresult[key] = (<any>defaults)[key];\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Make a copy of the source object.\r\n * @param source\r\n * @returns {Object}\r\n */\r\nexport function copy<T extends IMap<any>>(source:T):T\r\n{\r\n\treturn apply({}, source);\r\n}\r\n\r\n\r\n/**\r\n * Takes two objects and creates another with the values of both.\r\n * B overwrites A.\r\n * @param a\r\n * @param b\r\n */\r\nexport function merge<A extends IMap<any>, B extends IMap<any>>(\r\n\ta:A,\r\n\tb:B):A & B\r\n{\r\n\treturn apply(copy(a), b);\r\n}\r\n\r\n/**\r\n * Removes any keys that don't exist on the keyMap.\r\n * @param target\r\n * @param keyMap\r\n */\r\nexport function trim<TResult extends IMap<any>>(target:IMap<any>, keyMap:TResult):void //Partial<TResult>\r\n{\r\n\tfor(const key in target)\r\n\t{\r\n\t\tif(!keyMap.hasOwnProperty(key))\r\n\t\t{\r\n\t\t\tdelete target[key];\r\n\t\t}\r\n\t}\r\n\t//return <any>target;\r\n}\r\n\r\nexport function wipe(map:IMap<any>, depth:number = 1):void\r\n{\r\n\tif(map && depth)\r\n\t{\r\n\t\tfor(let key of Object.keys(map))\r\n\t\t{\r\n\t\t\tconst v = map[key];\r\n\t\t\tdelete map[key];\r\n\t\t\twipe(v, depth - 1);\r\n\t\t}\r\n\t}\r\n}"]}