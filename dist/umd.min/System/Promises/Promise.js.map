{"version":3,"sources":["System/Promises/Promise.js","System/Promises/Promise.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","isPromise","value","Types_1","hasMemberOfType","THEN","FUNCTION","resolve","resolver","promiseFactory","nextValue","TSDNPromise","wrap","handleResolution","p","ex","reject","handleResolutionMethods","targetFulfill","targetReject","handleDispatch","onFulfilled","onRejected","PromiseBase","doneNow","then","handleSyncIfPossible","thenSynchronous","newODE","ObjectDisposedException_1","ObjectDisposedException","Object","defineProperty","deferImmediate_1","DisposableBase_1","InvalidOperationException_1","ArgumentException_1","ArgumentNullException_1","ObjectPool_1","Set_1","defer_1","extends_1","__extends","VOID0","NULL","PROMISE","PROMISE_STATE","TARGET","PromiseState","_super","_state","_result","_error","_this","call","this","prototype","_onDispose","getState","get","enumerable","configurable","State","Pending","Fulfilled","Rejected","getResult","throwIfDisposed","getError","DisposableBase","_disposableObjectName","thenThis","result","error","thenAllowFatal","done","defer","delayFromNow","milliseconds","e","delayAfterResolve","isSettled","catchAllowFatal","fin","finallyAllowFatal","finallyThis","synchronous","f","deferImmediate","Resolvable","apply","arguments","state","Error","Resolved","PromiseWrapper","_target","ArgumentNullException","ArgumentException","t","forceSynchronous","resolveUsing","_waiting","push","Pool","init","_resolvedCalled","InvalidOperationException","rejectHandler","reason","console","warn","fulfillHandler","_emitDisposalRejection","d","wasDisposed","_rejectInternal","_resolveInternal","r","o","_i","o_1","length","c","promise","recycle","o_2","throwIfSettled","Promise","ArrayPromise","map","transform","reduce","reduction","initialValue","fulfilled","PROMISE_COLLECTION","PromiseCollection","source","_source","slice","all","race","waitAll","pipe","previous","current","i","array","getPool","pool","ObjectPool","take","add","group","first","rest","concat","promises","every","len","remaining","Set","cleanup","dispose","checkIfShouldResolve","count","onFulfill","remove","onReject","_loop_1","onResolved","_loop_2","filter","onResolve","promises_1","using","resolveAll","j","target","createFrom","freeze"],"mappings":"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","file":"Promise.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT\n * Although most of the following code is written from scratch, it is\n * heavily influenced by Q (https://github.com/kriskowal/q) and uses some of Q's spec.\n */\n/*\n * Resources:\n * https://promisesaplus.com/\n * https://github.com/kriskowal/q\n */\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"../Types\", \"../Threading/deferImmediate\", \"../Disposable/DisposableBase\", \"../Exceptions/InvalidOperationException\", \"../Exceptions/ArgumentException\", \"../Exceptions/ArgumentNullException\", \"../Disposable/ObjectPool\", \"../Collections/Set\", \"../Threading/defer\", \"../Disposable/ObjectDisposedException\", \"../../extends\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var Types_1 = require(\"../Types\");\n    var deferImmediate_1 = require(\"../Threading/deferImmediate\");\n    var DisposableBase_1 = require(\"../Disposable/DisposableBase\");\n    var InvalidOperationException_1 = require(\"../Exceptions/InvalidOperationException\");\n    var ArgumentException_1 = require(\"../Exceptions/ArgumentException\");\n    var ArgumentNullException_1 = require(\"../Exceptions/ArgumentNullException\");\n    var ObjectPool_1 = require(\"../Disposable/ObjectPool\");\n    var Set_1 = require(\"../Collections/Set\");\n    var defer_1 = require(\"../Threading/defer\");\n    var ObjectDisposedException_1 = require(\"../Disposable/ObjectDisposedException\");\n    var extends_1 = require(\"../../extends\");\n    //noinspection JSUnusedLocalSymbols\n    var __extends = extends_1.default;\n    var VOID0 = void 0, NULL = null, PROMISE = \"Promise\", PROMISE_STATE = PROMISE + \"State\", THEN = \"then\", TARGET = \"target\";\n    function isPromise(value) {\n        return Types_1.default.hasMemberOfType(value, THEN, Types_1.default.FUNCTION);\n    }\n    function resolve(value, resolver, promiseFactory) {\n        var nextValue = resolver\n            ? resolver(value)\n            : value;\n        return nextValue && isPromise(nextValue)\n            ? TSDNPromise.wrap(nextValue)\n            : promiseFactory(nextValue);\n    }\n    function handleResolution(p, value, resolver) {\n        try {\n            var v = resolver ? resolver(value) : value;\n            if (p) {\n                p.resolve(v);\n            }\n            return null;\n        }\n        catch (ex) {\n            if (p) {\n                p.reject(ex);\n            }\n            return ex;\n        }\n    }\n    function handleResolutionMethods(targetFulfill, targetReject, value, resolver) {\n        try {\n            var v = resolver ? resolver(value) : value;\n            if (targetFulfill)\n                targetFulfill(v);\n        }\n        catch (ex) {\n            if (targetReject)\n                targetReject(ex);\n        }\n    }\n    function handleDispatch(p, onFulfilled, onRejected) {\n        if (p instanceof PromiseBase) {\n            p.doneNow(onFulfilled, onRejected);\n        }\n        else {\n            p.then(onFulfilled, onRejected);\n        }\n    }\n    function handleSyncIfPossible(p, onFulfilled, onRejected) {\n        if (p instanceof PromiseBase)\n            return p.thenSynchronous(onFulfilled, onRejected);\n        else\n            return p.then(onFulfilled, onRejected);\n    }\n    function newODE() {\n        return new ObjectDisposedException_1.ObjectDisposedException(\"TSDNPromise\", \"An underlying promise-result was disposed.\");\n    }\n    var PromiseState = /** @class */ (function (_super) {\n        __extends(PromiseState, _super);\n        function PromiseState(_state, _result, _error) {\n            var _this = _super.call(this, PROMISE_STATE) || this;\n            _this._state = _state;\n            _this._result = _result;\n            _this._error = _error;\n            return _this;\n        }\n        PromiseState.prototype._onDispose = function () {\n            this._state = VOID0;\n            this._result = VOID0;\n            this._error = VOID0;\n        };\n        PromiseState.prototype.getState = function () {\n            return this._state;\n        };\n        Object.defineProperty(PromiseState.prototype, \"state\", {\n            get: function () {\n                return this._state;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PromiseState.prototype, \"isPending\", {\n            get: function () {\n                return this.getState() === TSDNPromise.State.Pending;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PromiseState.prototype, \"isSettled\", {\n            get: function () {\n                return this.getState() != TSDNPromise.State.Pending; // Will also include undefined==0 aka disposed!=resolved.\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PromiseState.prototype, \"isFulfilled\", {\n            get: function () {\n                return this.getState() === TSDNPromise.State.Fulfilled;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PromiseState.prototype, \"isRejected\", {\n            get: function () {\n                return this.getState() === TSDNPromise.State.Rejected;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /*\n         * Providing overrides allows for special defer or lazy sub classes.\n         */\n        PromiseState.prototype.getResult = function () {\n            return this._result;\n        };\n        Object.defineProperty(PromiseState.prototype, \"result\", {\n            get: function () {\n                this.throwIfDisposed();\n                return this.getResult();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        PromiseState.prototype.getError = function () {\n            return this._error;\n        };\n        Object.defineProperty(PromiseState.prototype, \"error\", {\n            get: function () {\n                this.throwIfDisposed();\n                return this.getError();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return PromiseState;\n    }(DisposableBase_1.DisposableBase));\n    exports.PromiseState = PromiseState;\n    var PromiseBase = /** @class */ (function (_super) {\n        __extends(PromiseBase, _super);\n        //readonly [Symbol.toStringTag]: \"Promise\";\n        function PromiseBase() {\n            var _this = _super.call(this, TSDNPromise.State.Pending) || this;\n            // @ts-ignore\n            _this._disposableObjectName = PROMISE;\n            return _this;\n        }\n        /**\n         * Same as 'thenSynchronous' but does not return the result.  Returns the current promise instead.\n         * You may not need an additional promise result, and this will not create a new one.\n         * @param onFulfilled\n         * @param onRejected\n         */\n        PromiseBase.prototype.thenThis = function (onFulfilled, onRejected) {\n            this.doneNow(onFulfilled, onRejected);\n            return this;\n        };\n        /**\n         * Standard .then method that defers execution until resolved.\n         * @param onFulfilled\n         * @param onRejected\n         * @returns {TSDNPromise}\n         */\n        PromiseBase.prototype.then = function (onFulfilled, onRejected) {\n            var _this = this;\n            this.throwIfDisposed();\n            return new TSDNPromise(function (resolve, reject) {\n                _this.doneNow(function (result) {\n                    return handleResolutionMethods(resolve, reject, result, onFulfilled);\n                }, function (error) {\n                    return onRejected\n                        ? handleResolutionMethods(resolve, reject, error, onRejected)\n                        : reject(error);\n                });\n            });\n        };\n        /**\n         * Same as .then but doesn't trap errors.  Exceptions may end up being fatal.\n         * @param onFulfilled\n         * @param onRejected\n         * @returns {TSDNPromise}\n         */\n        PromiseBase.prototype.thenAllowFatal = function (onFulfilled, onRejected) {\n            var _this = this;\n            this.throwIfDisposed();\n            return new TSDNPromise(function (resolve, reject) {\n                _this.doneNow(function (result) {\n                    return resolve((onFulfilled ? onFulfilled(result) : result));\n                }, function (error) {\n                    return reject(onRejected ? onRejected(error) : error);\n                });\n            });\n        };\n        /**\n         * .done is provided as a non-standard means that maps to similar functionality in other promise libraries.\n         * As stated by promisejs.org: 'then' is to 'done' as 'map' is to 'forEach'.\n         * @param onFulfilled\n         * @param onRejected\n         */\n        PromiseBase.prototype.done = function (onFulfilled, onRejected) {\n            var _this = this;\n            defer_1.defer(function () { return _this.doneNow(onFulfilled, onRejected); });\n        };\n        /**\n         * Will yield for a number of milliseconds from the time called before continuing.\n         * @param milliseconds\n         * @returns A promise that yields to the current execution and executes after a delay.\n         */\n        PromiseBase.prototype.delayFromNow = function (milliseconds) {\n            var _this = this;\n            if (milliseconds === void 0) { milliseconds = 0; }\n            this.throwIfDisposed();\n            return new TSDNPromise(function (resolve, reject) {\n                defer_1.defer(function () {\n                    _this.doneNow(function (v) { return resolve(v); }, function (e) { return reject(e); });\n                }, milliseconds);\n            }, true // Since the resolve/reject is deferred.\n            );\n        };\n        /**\n         * Will yield for a number of milliseconds from after this promise resolves.\n         * If the promise is already resolved, the delay will start from now.\n         * @param milliseconds\n         * @returns A promise that yields to the current execution and executes after a delay.\n         */\n        PromiseBase.prototype.delayAfterResolve = function (milliseconds) {\n            var _this = this;\n            if (milliseconds === void 0) { milliseconds = 0; }\n            this.throwIfDisposed();\n            if (this.isSettled)\n                return this.delayFromNow(milliseconds);\n            return new TSDNPromise(function (resolve, reject) {\n                _this.doneNow(function (v) { return defer_1.defer(function () { return resolve(v); }, milliseconds); }, function (e) { return defer_1.defer(function () { return reject(e); }, milliseconds); });\n            }, true // Since the resolve/reject is deferred.\n            );\n        };\n        /**\n         * Shortcut for trapping a rejection.\n         * @param onRejected\n         * @returns {PromiseBase<TResult>}\n         */\n        PromiseBase.prototype['catch'] = function (onRejected) {\n            return this.then(VOID0, onRejected);\n        };\n        /**\n         * Shortcut for trapping a rejection but will allow exceptions to propagate within the onRejected handler.\n         * @param onRejected\n         * @returns {PromiseBase<TResult>}\n         */\n        PromiseBase.prototype.catchAllowFatal = function (onRejected) {\n            return this.thenAllowFatal(VOID0, onRejected);\n        };\n        /**\n         * Shortcut to for handling either resolve or reject.\n         * @param fin\n         * @returns {PromiseBase<TResult>}\n         */\n        PromiseBase.prototype['finally'] = function (fin) {\n            return this.then(fin, fin);\n        };\n        /**\n         * Shortcut to for handling either resolve or reject but will allow exceptions to propagate within the handler.\n         * @param fin\n         * @returns {PromiseBase<TResult>}\n         */\n        PromiseBase.prototype.finallyAllowFatal = function (fin) {\n            return this.thenAllowFatal(fin, fin);\n        };\n        /**\n         * Shortcut to for handling either resolve or reject.  Returns the current promise instead.\n         * You may not need an additional promise result, and this will not create a new one.\n         * @param fin\n         * @param synchronous\n         * @returns {PromiseBase}\n         */\n        PromiseBase.prototype.finallyThis = function (fin, synchronous) {\n            var f = synchronous ? fin : function () { return deferImmediate_1.deferImmediate(fin); };\n            this.doneNow(f, f);\n            return this;\n        };\n        return PromiseBase;\n    }(PromiseState));\n    exports.PromiseBase = PromiseBase;\n    var Resolvable = /** @class */ (function (_super) {\n        __extends(Resolvable, _super);\n        function Resolvable() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        Resolvable.prototype.doneNow = function (onFulfilled, onRejected) {\n            this.throwIfDisposed();\n            switch (this.state) {\n                case TSDNPromise.State.Fulfilled:\n                    if (onFulfilled)\n                        onFulfilled(this._result);\n                    break;\n                case TSDNPromise.State.Rejected:\n                    if (onRejected)\n                        onRejected(this._error);\n                    break;\n            }\n        };\n        Resolvable.prototype.thenSynchronous = function (onFulfilled, onRejected) {\n            this.throwIfDisposed();\n            try {\n                switch (this.state) {\n                    case TSDNPromise.State.Fulfilled:\n                        return onFulfilled\n                            ? resolve(this._result, onFulfilled, TSDNPromise.resolve)\n                            : this; // Provided for catch cases.\n                    case TSDNPromise.State.Rejected:\n                        return onRejected\n                            ? resolve(this._error, onRejected, TSDNPromise.resolve)\n                            : this;\n                }\n            }\n            catch (ex) {\n                return new Rejected(ex);\n            }\n            throw new Error(\"Invalid state for a resolved promise.\");\n        };\n        return Resolvable;\n    }(PromiseBase));\n    exports.Resolvable = Resolvable;\n    /**\n     * The simplest usable version of a promise which returns synchronously the resolved state provided.\n     */\n    var Resolved = /** @class */ (function (_super) {\n        __extends(Resolved, _super);\n        function Resolved(state, result, error) {\n            var _this = _super.call(this) || this;\n            _this._result = result;\n            _this._error = error;\n            _this._state = state;\n            return _this;\n        }\n        return Resolved;\n    }(Resolvable));\n    exports.Resolved = Resolved;\n    /**\n     * A fulfilled Resolved<T>.  Provided for readability.\n     */\n    var Fulfilled = /** @class */ (function (_super) {\n        __extends(Fulfilled, _super);\n        function Fulfilled(value) {\n            return _super.call(this, TSDNPromise.State.Fulfilled, value) || this;\n        }\n        return Fulfilled;\n    }(Resolved));\n    exports.Fulfilled = Fulfilled;\n    /**\n     * A rejected Resolved<T>.  Provided for readability.\n     */\n    var Rejected = /** @class */ (function (_super) {\n        __extends(Rejected, _super);\n        function Rejected(error) {\n            return _super.call(this, TSDNPromise.State.Rejected, VOID0, error) || this;\n        }\n        return Rejected;\n    }(Resolved));\n    exports.Rejected = Rejected;\n    /**\n     * Provided as a means for extending the interface of other PromiseLike<T> objects.\n     */\n    var PromiseWrapper = /** @class */ (function (_super) {\n        __extends(PromiseWrapper, _super);\n        function PromiseWrapper(_target) {\n            var _this = _super.call(this) || this;\n            _this._target = _target;\n            if (!_target)\n                throw new ArgumentNullException_1.ArgumentNullException(TARGET);\n            if (!isPromise(_target))\n                throw new ArgumentException_1.ArgumentException(TARGET, \"Must be a promise-like object.\");\n            _target.then(function (v) {\n                _this._state = TSDNPromise.State.Fulfilled;\n                _this._result = v;\n                _this._error = VOID0;\n                _this._target = VOID0;\n            }, function (e) {\n                _this._state = TSDNPromise.State.Rejected;\n                _this._error = e;\n                _this._target = VOID0;\n            });\n            return _this;\n        }\n        PromiseWrapper.prototype.thenSynchronous = function (onFulfilled, onRejected) {\n            this.throwIfDisposed();\n            var t = this._target;\n            if (!t)\n                return _super.prototype.thenSynchronous.call(this, onFulfilled, onRejected);\n            return new TSDNPromise(function (resolve, reject) {\n                handleDispatch(t, function (result) { return handleResolutionMethods(resolve, reject, result, onFulfilled); }, function (error) { return onRejected\n                    ? handleResolutionMethods(resolve, null, error, onRejected)\n                    : reject(error); });\n            }, true);\n        };\n        PromiseWrapper.prototype.doneNow = function (onFulfilled, onRejected) {\n            this.throwIfDisposed();\n            var t = this._target;\n            if (t)\n                handleDispatch(t, onFulfilled, onRejected);\n            else\n                _super.prototype.doneNow.call(this, onFulfilled, onRejected);\n        };\n        PromiseWrapper.prototype._onDispose = function () {\n            _super.prototype._onDispose.call(this);\n            this._target = VOID0;\n        };\n        return PromiseWrapper;\n    }(Resolvable));\n    /**\n     * This promise class that facilitates pending resolution.\n     */\n    var TSDNPromise = /** @class */ (function (_super) {\n        __extends(TSDNPromise, _super);\n        /*\n         * A note about deferring:\n         * The caller can set resolveImmediate to true if they intend to initialize code that will end up being deferred itself.\n         * This eliminates the extra defer that will occur internally.\n         * But for the most part, resolveImmediate = false (the default) will ensure the constructor will not block.\n         *\n         * resolveUsing allows for the same ability but does not defer by default: allowing the caller to take on the work load.\n         * If calling resolve or reject and a deferred response is desired, then use deferImmediate with a closure to do so.\n         */\n        function TSDNPromise(resolver, forceSynchronous) {\n            if (forceSynchronous === void 0) { forceSynchronous = false; }\n            var _this = _super.call(this) || this;\n            if (resolver)\n                _this.resolveUsing(resolver, forceSynchronous);\n            return _this;\n        }\n        TSDNPromise.prototype.thenSynchronous = function (onFulfilled, onRejected) {\n            this.throwIfDisposed();\n            // Already fulfilled?\n            if (this._state)\n                return _super.prototype.thenSynchronous.call(this, onFulfilled, onRejected);\n            var p = new TSDNPromise();\n            (this._waiting || (this._waiting = []))\n                .push(Pool.init(onFulfilled, onRejected, p));\n            return p;\n        };\n        TSDNPromise.prototype.doneNow = function (onFulfilled, onRejected) {\n            this.throwIfDisposed();\n            // Already fulfilled?\n            if (this._state)\n                return _super.prototype.doneNow.call(this, onFulfilled, onRejected);\n            (this._waiting || (this._waiting = []))\n                .push(Pool.init(onFulfilled, onRejected));\n        };\n        TSDNPromise.prototype._onDispose = function () {\n            _super.prototype._onDispose.call(this);\n            this._resolvedCalled = VOID0;\n        };\n        TSDNPromise.prototype.resolveUsing = function (resolver, forceSynchronous) {\n            var _this = this;\n            if (forceSynchronous === void 0) { forceSynchronous = false; }\n            if (!resolver)\n                throw new ArgumentNullException_1.ArgumentNullException(\"resolver\");\n            if (this._resolvedCalled)\n                throw new InvalidOperationException_1.InvalidOperationException(\".resolve() already called.\");\n            if (this.state)\n                throw new InvalidOperationException_1.InvalidOperationException(\"Already resolved: \" + TSDNPromise.State[this.state]);\n            this._resolvedCalled = true;\n            var state = 0;\n            var rejectHandler = function (reason) {\n                if (state) {\n                    // Someone else's promise handling down stream could double call this. :\\\n                    console.warn(state == -1\n                        ? \"Rejection called multiple times\"\n                        : \"Rejection called after fulfilled.\");\n                }\n                else {\n                    state = -1;\n                    _this._resolvedCalled = false;\n                    _this.reject(reason);\n                }\n            };\n            var fulfillHandler = function (v) {\n                if (state) {\n                    // Someone else's promise handling down stream could double call this. :\\\n                    console.warn(state == 1\n                        ? \"Fulfill called multiple times\"\n                        : \"Fulfill called after rejection.\");\n                }\n                else {\n                    state = 1;\n                    _this._resolvedCalled = false;\n                    _this.resolve(v);\n                }\n            };\n            // There are some performance edge cases where there caller is not blocking upstream and does not need to defer.\n            if (forceSynchronous)\n                resolver(fulfillHandler, rejectHandler);\n            else\n                deferImmediate_1.deferImmediate(function () { return resolver(fulfillHandler, rejectHandler); });\n        };\n        TSDNPromise.prototype._emitDisposalRejection = function (p) {\n            var d = p.wasDisposed;\n            if (d)\n                this._rejectInternal(newODE());\n            return d;\n        };\n        TSDNPromise.prototype._resolveInternal = function (result) {\n            var _this = this;\n            if (this.wasDisposed)\n                return;\n            // Note: Avoid recursion if possible.\n            // Check ahead of time for resolution and resolve appropriately\n            while (result instanceof PromiseBase) {\n                var r = result;\n                if (this._emitDisposalRejection(r))\n                    return;\n                switch (r.state) {\n                    case TSDNPromise.State.Pending:\n                        r.doneNow(function (v) { return _this._resolveInternal(v); }, function (e) { return _this._rejectInternal(e); });\n                        return;\n                    case TSDNPromise.State.Rejected:\n                        this._rejectInternal(r.error);\n                        return;\n                    case TSDNPromise.State.Fulfilled:\n                        result = r.result;\n                        break;\n                }\n            }\n            if (isPromise(result)) {\n                result.then(function (v) { return _this._resolveInternal(v); }, function (e) { return _this._rejectInternal(e); });\n            }\n            else {\n                this._state = TSDNPromise.State.Fulfilled;\n                this._result = result;\n                this._error = VOID0;\n                var o = this._waiting;\n                if (o) {\n                    this._waiting = VOID0;\n                    for (var _i = 0, o_1 = o; _i < o_1.length; _i++) {\n                        var c = o_1[_i];\n                        var onFulfilled = c.onFulfilled, promise = c.promise;\n                        Pool.recycle(c);\n                        //let ex =\n                        handleResolution(promise, result, onFulfilled);\n                        //if(!p && ex) console.error(\"Unhandled exception in onFulfilled:\",ex);\n                    }\n                    o.length = 0;\n                }\n            }\n        };\n        TSDNPromise.prototype._rejectInternal = function (error) {\n            if (this.wasDisposed)\n                return;\n            this._state = TSDNPromise.State.Rejected;\n            this._error = error;\n            var o = this._waiting;\n            if (o) {\n                this._waiting = null; // null = finished. undefined = hasn't started.\n                for (var _i = 0, o_2 = o; _i < o_2.length; _i++) {\n                    var c = o_2[_i];\n                    var onRejected = c.onRejected, promise = c.promise;\n                    Pool.recycle(c);\n                    if (onRejected) {\n                        //let ex =\n                        handleResolution(promise, error, onRejected);\n                        //if(!p && ex) console.error(\"Unhandled exception in onRejected:\",ex);\n                    }\n                    else if (promise) {\n                        promise.reject(error);\n                    }\n                }\n                o.length = 0;\n            }\n        };\n        TSDNPromise.prototype.resolve = function (result, throwIfSettled) {\n            if (throwIfSettled === void 0) { throwIfSettled = false; }\n            this.throwIfDisposed();\n            if (result == this)\n                throw new InvalidOperationException_1.InvalidOperationException(\"Cannot resolve a promise as itself.\");\n            if (this._state) {\n                // Same value? Ignore...\n                if (!throwIfSettled || this._state == TSDNPromise.State.Fulfilled && this._result === result)\n                    return;\n                throw new InvalidOperationException_1.InvalidOperationException(\"Changing the fulfilled state/value of a promise is not supported.\");\n            }\n            if (this._resolvedCalled) {\n                if (throwIfSettled)\n                    throw new InvalidOperationException_1.InvalidOperationException(\".resolve() already called.\");\n                return;\n            }\n            this._resolveInternal(result);\n        };\n        TSDNPromise.prototype.reject = function (error, throwIfSettled) {\n            if (throwIfSettled === void 0) { throwIfSettled = false; }\n            this.throwIfDisposed();\n            if (this._state) {\n                // Same value? Ignore...\n                if (!throwIfSettled || this._state == TSDNPromise.State.Rejected && this._error === error)\n                    return;\n                throw new InvalidOperationException_1.InvalidOperationException(\"Changing the rejected state/value of a promise is not supported.\");\n            }\n            if (this._resolvedCalled) {\n                if (throwIfSettled)\n                    throw new InvalidOperationException_1.InvalidOperationException(\".resolve() already called.\");\n                return;\n            }\n            this._rejectInternal(error);\n        };\n        return TSDNPromise;\n    }(Resolvable));\n    exports.TSDNPromise = TSDNPromise;\n    exports.Promise = TSDNPromise;\n    /**\n     * By providing an ArrayPromise we expose useful methods/shortcuts for dealing with array results.\n     */\n    var ArrayPromise = /** @class */ (function (_super) {\n        __extends(ArrayPromise, _super);\n        function ArrayPromise() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        /**\n         * Simplifies the use of a map function on an array of results when the source is assured to be an array.\n         * @param transform\n         * @returns {PromiseBase<Array<any>>}\n         */\n        ArrayPromise.prototype.map = function (transform) {\n            var _this = this;\n            this.throwIfDisposed();\n            return new ArrayPromise(function (resolve) {\n                _this.doneNow(function (result) { return resolve(result.map(transform)); });\n            }, true);\n        };\n        /**\n         * Simplifies the use of a reduce function on an array of results when the source is assured to be an array.\n         * @param reduction\n         * @param initialValue\n         * @returns {PromiseBase<any>}\n         */\n        ArrayPromise.prototype.reduce = function (reduction, initialValue) {\n            return this\n                .thenSynchronous(function (result) { return result.reduce(reduction, initialValue); });\n        };\n        ArrayPromise.fulfilled = function (value) {\n            return new ArrayPromise(function (resolve) { return value; }, true);\n        };\n        return ArrayPromise;\n    }(TSDNPromise));\n    exports.ArrayPromise = ArrayPromise;\n    var PROMISE_COLLECTION = \"PromiseCollection\";\n    /**\n     * A Promise collection exposes useful methods for handling a collection of promises and their results.\n     */\n    var PromiseCollection = /** @class */ (function (_super) {\n        __extends(PromiseCollection, _super);\n        function PromiseCollection(source) {\n            var _this = _super.call(this, PROMISE_COLLECTION) || this;\n            _this._source = source && source.slice() || [];\n            return _this;\n        }\n        PromiseCollection.prototype._onDispose = function () {\n            _super.prototype._onDispose.call(this);\n            this._source.length = 0;\n            this._source = null;\n        };\n        Object.defineProperty(PromiseCollection.prototype, \"promises\", {\n            /**\n             * Returns a copy of the source promises.\n             * @returns {PromiseLike<PromiseLike<any>>[]}\n             */\n            get: function () {\n                this.throwIfDisposed();\n                return this._source.slice();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, or is rejected with the same rejection reason as the first promise to be rejected.\n         * @returns {PromiseBase<any>}\n         */\n        PromiseCollection.prototype.all = function () {\n            this.throwIfDisposed();\n            return TSDNPromise.all(this._source);\n        };\n        /**\n         * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\n         * or rejected.\n         * @returns {PromiseBase<any>} A new Promise.\n         */\n        PromiseCollection.prototype.race = function () {\n            this.throwIfDisposed();\n            return TSDNPromise.race(this._source);\n        };\n        /**\n         * Returns a promise that is fulfilled with array of provided promises when all provided promises have resolved (fulfill or reject).\n         * Unlike .all this method waits for all rejections as well as fulfillment.\n         * @returns {PromiseBase<PromiseLike<any>[]>}\n         */\n        PromiseCollection.prototype.waitAll = function () {\n            this.throwIfDisposed();\n            return TSDNPromise.waitAll(this._source);\n        };\n        /**\n         * Waits for all the values to resolve and then applies a transform.\n         * @param transform\n         * @returns {PromiseBase<Array<any>>}\n         */\n        PromiseCollection.prototype.map = function (transform) {\n            var _this = this;\n            this.throwIfDisposed();\n            return new ArrayPromise(function (resolve) {\n                _this.all()\n                    .doneNow(function (result) { return resolve(result.map(transform)); });\n            }, true);\n        };\n        /**\n         * Applies a transform to each promise and defers the result.\n         * Unlike map, this doesn't wait for all promises to resolve, ultimately improving the async nature of the request.\n         * @param transform\n         * @returns {PromiseCollection<U>}\n         */\n        PromiseCollection.prototype.pipe = function (transform) {\n            this.throwIfDisposed();\n            return new PromiseCollection(this._source.map(function (p) { return handleSyncIfPossible(p, transform); }));\n        };\n        /**\n         * Behaves like array reduce.\n         * Creates the promise chain necessary to produce the desired result.\n         * @param reduction\n         * @param initialValue\n         * @returns {PromiseBase<PromiseLike<any>>}\n         */\n        PromiseCollection.prototype.reduce = function (reduction, initialValue) {\n            this.throwIfDisposed();\n            return TSDNPromise.wrap(this._source\n                .reduce(function (previous, current, i, array) {\n                return handleSyncIfPossible(previous, function (p) { return handleSyncIfPossible(current, function (c) { return reduction(p, c, i, array); }); });\n            }, isPromise(initialValue)\n                ? initialValue\n                : new Fulfilled(initialValue)));\n        };\n        return PromiseCollection;\n    }(DisposableBase_1.DisposableBase));\n    exports.PromiseCollection = PromiseCollection;\n    var Pool;\n    (function (Pool) {\n        var pool;\n        //noinspection JSUnusedLocalSymbols\n        function getPool() {\n            return pool\n                || (pool = new ObjectPool_1.ObjectPool(40, factory, function (c) {\n                    c.onFulfilled = NULL;\n                    c.onRejected = NULL;\n                    c.promise = NULL;\n                }));\n        }\n        function factory() {\n            return {\n                onFulfilled: NULL,\n                onRejected: NULL,\n                promise: NULL\n            };\n        }\n        function init(onFulfilled, onRejected, promise) {\n            var c = getPool().take();\n            c.onFulfilled = onFulfilled || undefined;\n            c.onRejected = onRejected || undefined;\n            c.promise = promise;\n            return c;\n        }\n        Pool.init = init;\n        function recycle(c) {\n            getPool().add(c);\n        }\n        Pool.recycle = recycle;\n    })(Pool || (Pool = {}));\n    (function (TSDNPromise) {\n        /**\n         * The state of a promise.\n         * https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md\n         * If a promise is disposed the value will be undefined which will also evaluate (promise.state)==false.\n         */\n        var State;\n        (function (State) {\n            State[State[\"Pending\"] = 0] = \"Pending\";\n            State[State[\"Fulfilled\"] = 1] = \"Fulfilled\";\n            State[State[\"Rejected\"] = -1] = \"Rejected\";\n        })(State = TSDNPromise.State || (TSDNPromise.State = {}));\n        Object.freeze(State);\n        function factory(e) {\n            return new TSDNPromise(e);\n        }\n        TSDNPromise.factory = factory;\n        function group(first) {\n            var rest = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                rest[_i - 1] = arguments[_i];\n            }\n            if (!first && !rest.length)\n                throw new ArgumentNullException_1.ArgumentNullException(\"promises\");\n            return new PromiseCollection(((first) instanceof (Array) ? first : [first])\n                .concat(rest));\n        }\n        TSDNPromise.group = group;\n        function all(first) {\n            var rest = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                rest[_i - 1] = arguments[_i];\n            }\n            if (!first && !rest.length)\n                throw new ArgumentNullException_1.ArgumentNullException(\"promises\");\n            var promises = ((first) instanceof (Array) ? first : [first]).concat(rest); // yay a copy!\n            if (!promises.length || promises.every(function (v) { return !v; }))\n                return new ArrayPromise(function (r) { return r(promises); }, true); // it's a new empty, reuse it. :|\n            // Eliminate deferred and take the parent since all .then calls happen on next cycle anyway.\n            return new ArrayPromise(function (resolve, reject) {\n                var result = [];\n                var len = promises.length;\n                result.length = len;\n                // Using a set instead of -- a number is more reliable if just in case one of the provided promises resolves twice.\n                var remaining = new Set_1.Set(promises.map(function (v, i) { return i; })); // get all the indexes...\n                var cleanup = function () {\n                    reject = VOID0;\n                    resolve = VOID0;\n                    promises.length = 0;\n                    promises = VOID0;\n                    remaining.dispose();\n                    remaining = VOID0;\n                };\n                var checkIfShouldResolve = function () {\n                    var r = resolve;\n                    if (r && !remaining.count) {\n                        cleanup();\n                        r(result);\n                    }\n                };\n                var onFulfill = function (v, i) {\n                    if (resolve) {\n                        result[i] = v;\n                        remaining.remove(i);\n                        checkIfShouldResolve();\n                    }\n                };\n                var onReject = function (e) {\n                    var r = reject;\n                    if (r) {\n                        cleanup();\n                        r(e);\n                    }\n                };\n                var _loop_1 = function (i) {\n                    var p = promises[i];\n                    if (p)\n                        p.then(function (v) { return onFulfill(v, i); }, onReject);\n                    else\n                        remaining.remove(i);\n                    checkIfShouldResolve();\n                };\n                for (var i = 0; remaining && i < len; i++) {\n                    _loop_1(i);\n                }\n            });\n        }\n        TSDNPromise.all = all;\n        function waitAll(first) {\n            var rest = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                rest[_i - 1] = arguments[_i];\n            }\n            if (!first && !rest.length)\n                throw new ArgumentNullException_1.ArgumentNullException(\"promises\");\n            var promises = ((first) instanceof (Array) ? first : [first]).concat(rest); // yay a copy!\n            if (!promises.length || promises.every(function (v) { return !v; }))\n                return new ArrayPromise(function (r) { return r(promises); }, true); // it's a new empty, reuse it. :|\n            // Eliminate deferred and take the parent since all .then calls happen on next cycle anyway.\n            return new ArrayPromise(function (resolve, reject) {\n                var len = promises.length;\n                // Using a set instead of -- a number is more reliable if just in case one of the provided promises resolves twice.\n                var remaining = new Set_1.Set(promises.map(function (v, i) { return i; })); // get all the indexes...\n                var cleanup = function () {\n                    reject = NULL;\n                    resolve = NULL;\n                    remaining.dispose();\n                    remaining = NULL;\n                };\n                var checkIfShouldResolve = function () {\n                    var r = resolve;\n                    if (r && !remaining.count) {\n                        cleanup();\n                        r(promises);\n                    }\n                };\n                var onResolved = function (i) {\n                    if (remaining) {\n                        remaining.remove(i);\n                        checkIfShouldResolve();\n                    }\n                };\n                var _loop_2 = function (i) {\n                    var p = promises[i];\n                    if (p)\n                        p.then(function (v) { return onResolved(i); }, function (e) { return onResolved(i); });\n                    else\n                        onResolved(i);\n                };\n                for (var i = 0; remaining && i < len; i++) {\n                    _loop_2(i);\n                }\n            });\n        }\n        TSDNPromise.waitAll = waitAll;\n        function race(first) {\n            var rest = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                rest[_i - 1] = arguments[_i];\n            }\n            var promises = first && ((first) instanceof (Array) ? first : [first]).concat(rest); // yay a copy?\n            if (!promises || !promises.length || !(promises = promises.filter(function (v) { return v != null; })).length)\n                throw new ArgumentException_1.ArgumentException(\"Nothing to wait for.\");\n            var len = promises.length;\n            // Only one?  Nothing to race.\n            if (len == 1)\n                return wrap(promises[0]);\n            // Look for already resolved promises and the first one wins.\n            for (var i = 0; i < len; i++) {\n                var p = promises[i];\n                if (p instanceof PromiseBase && p.isSettled)\n                    return p;\n            }\n            return new TSDNPromise(function (resolve, reject) {\n                var cleanup = function () {\n                    reject = NULL;\n                    resolve = NULL;\n                    promises.length = 0;\n                    promises = NULL;\n                };\n                var onResolve = function (r, v) {\n                    if (r) {\n                        cleanup();\n                        r(v);\n                    }\n                };\n                var onFulfill = function (v) { return onResolve(resolve, v); };\n                var onReject = function (e) { return onResolve(reject, e); };\n                for (var _i = 0, promises_1 = promises; _i < promises_1.length; _i++) {\n                    var p = promises_1[_i];\n                    if (!resolve)\n                        break;\n                    p.then(onFulfill, onReject);\n                }\n            });\n        }\n        TSDNPromise.race = race;\n        function resolve(value) {\n            return isPromise(value) ? wrap(value) : new Fulfilled(value);\n        }\n        TSDNPromise.resolve = resolve;\n        /**\n         * Syntactic shortcut for avoiding 'new'.\n         * @param resolver\n         * @param forceSynchronous\n         * @returns {TSDNPromise}\n         */\n        function using(resolver, forceSynchronous) {\n            if (forceSynchronous === void 0) { forceSynchronous = false; }\n            return new TSDNPromise(resolver, forceSynchronous);\n        }\n        TSDNPromise.using = using;\n        function resolveAll(first) {\n            var rest = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                rest[_i - 1] = arguments[_i];\n            }\n            if (!first && !rest.length)\n                throw new ArgumentNullException_1.ArgumentNullException(\"resolutions\");\n            return new PromiseCollection(((first) instanceof (Array) ? first : [first])\n                .concat(rest)\n                .map(function (v) { return resolve(v); }));\n        }\n        TSDNPromise.resolveAll = resolveAll;\n        /**\n         * Creates a PromiseCollection containing promises that will resolve on the next tick using the transform function.\n         * This utility function does not chain promises together to create the result,\n         * it only uses one promise per transform.\n         * @param source\n         * @param transform\n         * @returns {PromiseCollection<T>}\n         */\n        function map(source, transform) {\n            return new PromiseCollection(source.map(function (d) { return new TSDNPromise(function (r, j) {\n                try {\n                    r(transform(d));\n                }\n                catch (ex) {\n                    j(ex);\n                }\n            }); }));\n        }\n        TSDNPromise.map = map;\n        /**\n         * Creates a new rejected promise for the provided reason.\n         * @param reason The reason the promise was rejected.\n         * @returns A new rejected Promise.\n         */\n        function reject(reason) {\n            return new Rejected(reason);\n        }\n        TSDNPromise.reject = reject;\n        /**\n         * Takes any Promise-Like object and ensures an extended version of it from this module.\n         * @param target The Promise-Like object\n         * @returns A new target that simply extends the target.\n         */\n        function wrap(target) {\n            if (!target)\n                throw new ArgumentNullException_1.ArgumentNullException(TARGET);\n            return isPromise(target)\n                ? (target instanceof PromiseBase ? target : new PromiseWrapper(target))\n                : new Fulfilled(target);\n        }\n        TSDNPromise.wrap = wrap;\n        /**\n         * A function that acts like a 'then' method (aka then-able) can be extended by providing a function that takes an onFulfill and onReject.\n         * @param then\n         * @returns {PromiseWrapper<T>}\n         */\n        function createFrom(then) {\n            if (!then)\n                throw new ArgumentNullException_1.ArgumentNullException(THEN);\n            return new PromiseWrapper({ then: then });\n        }\n        TSDNPromise.createFrom = createFrom;\n    })(TSDNPromise = exports.TSDNPromise || (exports.TSDNPromise = {}));\n    exports.TSDNPromise = TSDNPromise;\n    exports.Promise = TSDNPromise;\n    exports.default = TSDNPromise;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT\r\n * Although most of the following code is written from scratch, it is\r\n * heavily influenced by Q (https://github.com/kriskowal/q) and uses some of Q's spec.\r\n */\r\n/*\r\n * Resources:\r\n * https://promisesaplus.com/\r\n * https://github.com/kriskowal/q\r\n */\r\n\r\nimport Type from \"../Types\";\r\nimport {deferImmediate} from \"../Threading/deferImmediate\";\r\nimport {DisposableBase} from \"../Disposable/DisposableBase\";\r\nimport {InvalidOperationException} from \"../Exceptions/InvalidOperationException\";\r\nimport {ArgumentException} from \"../Exceptions/ArgumentException\";\r\nimport {ArgumentNullException} from \"../Exceptions/ArgumentNullException\";\r\nimport {ObjectPool} from \"../Disposable/ObjectPool\";\r\nimport {Set} from \"../Collections/Set\";\r\nimport {defer} from \"../Threading/defer\";\r\nimport {ObjectDisposedException} from \"../Disposable/ObjectDisposedException\";\r\nimport {Closure, Selector} from \"../FunctionTypes\";\r\nimport __extendsImport from \"../../extends\";\r\n//noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\nconst VOID0:any     = void 0,\r\n      NULL:any      = null,\r\n      PROMISE       = \"Promise\",\r\n      PROMISE_STATE = PROMISE + \"State\",\r\n      THEN          = \"then\",\r\n      TARGET        = \"target\";\r\n\r\nfunction isPromise<T>(value:any):value is PromiseLike<T>\r\n{\r\n\treturn Type.hasMemberOfType(value, THEN, Type.FUNCTION);\r\n}\r\n\r\nexport type Resolver = Selector<TSDNPromise.Resolution<any>, any> | null | undefined;\r\n\r\nfunction resolve<T>(\r\n\tvalue:TSDNPromise.Resolution<T>, resolver:Resolver,\r\n\tpromiseFactory:(v:any) => PromiseBase<any>):PromiseBase<any>\r\n{\r\n\tlet nextValue = resolver\r\n\t\t? resolver(value)\r\n\t\t: value;\r\n\r\n\treturn nextValue && isPromise(nextValue)\r\n\t\t? TSDNPromise.wrap(nextValue)\r\n\t\t: promiseFactory(nextValue);\r\n}\r\n\r\nfunction handleResolution(\r\n\tp:TSDNPromise<any> | null | undefined,\r\n\tvalue:TSDNPromise.Resolution<any>,\r\n\tresolver?:Resolver):any\r\n{\r\n\ttry\r\n\t{\r\n\t\tlet v = resolver ? resolver(value) : value;\r\n\t\tif(p)\r\n\t\t{ //noinspection JSIgnoredPromiseFromCall\r\n\t\t\tp.resolve(v);\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\tcatch(ex)\r\n\t{\r\n\t\tif(p)\r\n\t\t{ //noinspection JSIgnoredPromiseFromCall\r\n\t\t\tp.reject(ex);\r\n\t\t}\r\n\t\treturn ex;\r\n\t}\r\n}\r\n\r\nfunction handleResolutionMethods(\r\n\ttargetFulfill:TSDNPromise.Fulfill<any, any>,\r\n\ttargetReject:TSDNPromise.Reject<any>,\r\n\tvalue:TSDNPromise.Resolution<any>,\r\n\tresolver?:Resolver):void\r\n{\r\n\ttry\r\n\t{\r\n\t\tlet v = resolver ? resolver(value) : value;\r\n\t\tif(targetFulfill) targetFulfill(v);\r\n\t}\r\n\tcatch(ex)\r\n\t{ if(targetReject) targetReject(ex); }\r\n}\r\n\r\nfunction handleDispatch<T, TFulfilled = T, TRejected = never>(\r\n\tp:PromiseLike<T>,\r\n\tonFulfilled:TSDNPromise.Fulfill<T, TFulfilled>,\r\n\tonRejected?:TSDNPromise.Reject<TRejected>):void\r\n{\r\n\tif(p instanceof PromiseBase)\r\n\t{\r\n\t\tp.doneNow(onFulfilled, onRejected);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tp.then(<any>onFulfilled, onRejected);\r\n\t}\r\n}\r\n\r\nfunction handleSyncIfPossible<T, TFulfilled = T, TRejected = never>(\r\n\tp:PromiseLike<T>,\r\n\tonFulfilled:TSDNPromise.Fulfill<T, TFulfilled>,\r\n\tonRejected?:TSDNPromise.Reject<TRejected>):PromiseLike<TFulfilled | TRejected>\r\n{\r\n\tif(p instanceof PromiseBase)\r\n\t\treturn p.thenSynchronous(onFulfilled, onRejected);\r\n\telse\r\n\t\treturn p.then(onFulfilled, onRejected);\r\n}\r\n\r\nfunction newODE()\r\n{\r\n\treturn new ObjectDisposedException(\"TSDNPromise\", \"An underlying promise-result was disposed.\");\r\n}\r\n\r\nexport class PromiseState<T>\r\n\textends DisposableBase\r\n{\r\n\r\n\tconstructor(\r\n\t\tprotected _state:TSDNPromise.State,\r\n\t\tprotected _result?:T,\r\n\t\tprotected _error?:any)\r\n\t{\r\n\t\tsuper(PROMISE_STATE);\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tthis._state = VOID0;\r\n\t\tthis._result = VOID0;\r\n\t\tthis._error = VOID0;\r\n\t}\r\n\r\n\tprotected getState():TSDNPromise.State\r\n\t{\r\n\t\treturn this._state;\r\n\t}\r\n\r\n\tget state():TSDNPromise.State\r\n\t{\r\n\t\treturn this._state;\r\n\t}\r\n\r\n\tget isPending():boolean\r\n\t{\r\n\t\treturn this.getState()===TSDNPromise.State.Pending;\r\n\t}\r\n\r\n\tget isSettled():boolean\r\n\t{\r\n\t\treturn this.getState()!=TSDNPromise.State.Pending; // Will also include undefined==0 aka disposed!=resolved.\r\n\t}\r\n\r\n\tget isFulfilled():boolean\r\n\t{\r\n\t\treturn this.getState()===TSDNPromise.State.Fulfilled;\r\n\t}\r\n\r\n\tget isRejected():boolean\r\n\t{\r\n\t\treturn this.getState()===TSDNPromise.State.Rejected;\r\n\t}\r\n\r\n\t/*\r\n\t * Providing overrides allows for special defer or lazy sub classes.\r\n\t */\r\n\tprotected getResult():T | undefined\r\n\t{\r\n\t\treturn this._result;\r\n\t}\r\n\r\n\tget result():T | undefined\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn this.getResult();\r\n\t}\r\n\r\n\tprotected getError():any\r\n\t{\r\n\t\treturn this._error;\r\n\t}\r\n\r\n\tget error():any\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn this.getError();\r\n\t}\r\n\r\n}\r\n\r\nexport abstract class PromiseBase<T>\r\n\textends PromiseState<T>\r\n\timplements PromiseLike<T>// , Promise<T>\r\n{\r\n\t//readonly [Symbol.toStringTag]: \"Promise\";\r\n\r\n\tconstructor()\r\n\t{\r\n\t\tsuper(TSDNPromise.State.Pending);\r\n\t\t// @ts-ignore\r\n\t\tthis._disposableObjectName = PROMISE;\r\n\t}\r\n\r\n\t/**\r\n\t * .doneNow is provided as a non-standard means that synchronously resolves as the end of a promise chain.\r\n\t * As stated by promisejs.org: 'then' is to 'done' as 'map' is to 'forEach'.\r\n\t * It is the underlying method by which propagation occurs.\r\n\t * @param onFulfilled\r\n\t * @param onRejected\r\n\t */\r\n\tabstract doneNow(\r\n\t\tonFulfilled:TSDNPromise.Fulfill<T, any>,\r\n\t\tonRejected?:TSDNPromise.Reject<any>):void;\r\n\r\n\t/**\r\n\t * Calls the respective handlers once the promise is resolved.\r\n\t * @param onFulfilled\r\n\t * @param onRejected\r\n\t */\r\n\tabstract thenSynchronous<TFulfilled = T, TRejected = never>(\r\n\t\tonFulfilled:TSDNPromise.Fulfill<T, TFulfilled>,\r\n\t\tonRejected?:TSDNPromise.Reject<TRejected>):PromiseBase<TFulfilled | TRejected>;\r\n\r\n\t/**\r\n\t * Same as 'thenSynchronous' but does not return the result.  Returns the current promise instead.\r\n\t * You may not need an additional promise result, and this will not create a new one.\r\n\t * @param onFulfilled\r\n\t * @param onRejected\r\n\t */\r\n\tthenThis(\r\n\t\tonFulfilled:TSDNPromise.Fulfill<T, any>,\r\n\t\tonRejected?:TSDNPromise.Reject<any>):this\r\n\t{\r\n\t\tthis.doneNow(onFulfilled, onRejected);\r\n\t\treturn this;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Standard .then method that defers execution until resolved.\r\n\t * @param onFulfilled\r\n\t * @param onRejected\r\n\t * @returns {TSDNPromise}\r\n\t */\r\n\r\n\tthen<TFulfilled = T, TRejected = never>(\r\n\t\tonFulfilled:TSDNPromise.Fulfill<T, TFulfilled>,\r\n\t\tonRejected?:TSDNPromise.Reject<TRejected>):PromiseBase<TFulfilled | TRejected>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\treturn new TSDNPromise<TFulfilled | TRejected>((resolve, reject) => {\r\n\t\t\tthis.doneNow(\r\n\t\t\t\tresult =>\r\n\t\t\t\t\thandleResolutionMethods(resolve, reject, result, onFulfilled),\r\n\t\t\t\terror =>\r\n\t\t\t\t\tonRejected\r\n\t\t\t\t\t\t? handleResolutionMethods(resolve, reject, error, onRejected)\r\n\t\t\t\t\t\t: reject(error)\r\n\t\t\t);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Same as .then but doesn't trap errors.  Exceptions may end up being fatal.\r\n\t * @param onFulfilled\r\n\t * @param onRejected\r\n\t * @returns {TSDNPromise}\r\n\t */\r\n\tthenAllowFatal<TFulfilled = T, TRejected = never>(\r\n\t\tonFulfilled:TSDNPromise.Fulfill<T, TFulfilled>,\r\n\t\tonRejected?:TSDNPromise.Reject<TRejected>):PromiseBase<TFulfilled | TRejected>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\treturn new TSDNPromise<TFulfilled | TRejected>((resolve, reject) => {\r\n\t\t\tthis.doneNow(\r\n\t\t\t\tresult =>\r\n\t\t\t\t\tresolve(<any>(onFulfilled ? onFulfilled(result) : result)),\r\n\t\t\t\terror =>\r\n\t\t\t\t\treject(onRejected ? onRejected(error) : error)\r\n\t\t\t);\r\n\t\t});\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * .done is provided as a non-standard means that maps to similar functionality in other promise libraries.\r\n\t * As stated by promisejs.org: 'then' is to 'done' as 'map' is to 'forEach'.\r\n\t * @param onFulfilled\r\n\t * @param onRejected\r\n\t */\r\n\tdone(\r\n\t\tonFulfilled:TSDNPromise.Fulfill<T, any>,\r\n\t\tonRejected?:TSDNPromise.Reject<any>):void\r\n\t{\r\n\t\tdefer(() => this.doneNow(onFulfilled, onRejected));\r\n\t}\r\n\r\n\t/**\r\n\t * Will yield for a number of milliseconds from the time called before continuing.\r\n\t * @param milliseconds\r\n\t * @returns A promise that yields to the current execution and executes after a delay.\r\n\t */\r\n\tdelayFromNow(milliseconds:number = 0):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\treturn new TSDNPromise<T>(\r\n\t\t\t(resolve, reject) => {\r\n\t\t\t\tdefer(() => {\r\n\t\t\t\t\tthis.doneNow(\r\n\t\t\t\t\t\tv => resolve(v),\r\n\t\t\t\t\t\te => reject(e));\r\n\t\t\t\t}, milliseconds)\r\n\t\t\t},\r\n\t\t\ttrue // Since the resolve/reject is deferred.\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Will yield for a number of milliseconds from after this promise resolves.\r\n\t * If the promise is already resolved, the delay will start from now.\r\n\t * @param milliseconds\r\n\t * @returns A promise that yields to the current execution and executes after a delay.\r\n\t */\r\n\tdelayAfterResolve(milliseconds:number = 0):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tif(this.isSettled) return this.delayFromNow(milliseconds);\r\n\r\n\t\treturn new TSDNPromise<T>(\r\n\t\t\t(resolve, reject) => {\r\n\t\t\t\tthis.doneNow(\r\n\t\t\t\t\tv => defer(() => resolve(v), milliseconds),\r\n\t\t\t\t\te => defer(() => reject(e), milliseconds))\r\n\t\t\t},\r\n\t\t\ttrue // Since the resolve/reject is deferred.\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Shortcut for trapping a rejection.\r\n\t * @param onRejected\r\n\t * @returns {PromiseBase<TResult>}\r\n\t */\r\n\t'catch'<TResult = never>(onRejected:TSDNPromise.Reject<TResult>):PromiseBase<T | TResult>\r\n\t{\r\n\t\treturn this.then(VOID0, onRejected)\r\n\t}\r\n\r\n\t/**\r\n\t * Shortcut for trapping a rejection but will allow exceptions to propagate within the onRejected handler.\r\n\t * @param onRejected\r\n\t * @returns {PromiseBase<TResult>}\r\n\t */\r\n\tcatchAllowFatal<TResult = never>(onRejected:TSDNPromise.Reject<TResult>):PromiseBase<T | TResult>\r\n\t{\r\n\t\treturn this.thenAllowFatal(VOID0, onRejected)\r\n\t}\r\n\r\n\t/**\r\n\t * Shortcut to for handling either resolve or reject.\r\n\t * @param fin\r\n\t * @returns {PromiseBase<TResult>}\r\n\t */\r\n\t'finally'<TResult = never>(fin:() => TSDNPromise.Resolution<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\treturn this.then(fin, fin);\r\n\t}\r\n\r\n\t/**\r\n\t * Shortcut to for handling either resolve or reject but will allow exceptions to propagate within the handler.\r\n\t * @param fin\r\n\t * @returns {PromiseBase<TResult>}\r\n\t */\r\n\tfinallyAllowFatal<TResult = never>(fin:() => TSDNPromise.Resolution<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\treturn this.thenAllowFatal(fin, fin);\r\n\t}\r\n\r\n\t/**\r\n\t * Shortcut to for handling either resolve or reject.  Returns the current promise instead.\r\n\t * You may not need an additional promise result, and this will not create a new one.\r\n\t * @param fin\r\n\t * @param synchronous\r\n\t * @returns {PromiseBase}\r\n\t */\r\n\tfinallyThis(fin:Closure, synchronous?:boolean):this\r\n\t{\r\n\t\tconst f:Closure = synchronous ? fin : () => deferImmediate(fin);\r\n\t\tthis.doneNow(f, f);\r\n\t\treturn this;\r\n\t}\r\n\r\n}\r\n\r\nexport abstract class Resolvable<T>\r\n\textends PromiseBase<T>\r\n{\r\n\r\n\tdoneNow(\r\n\t\tonFulfilled:TSDNPromise.Fulfill<T, any>,\r\n\t\tonRejected?:TSDNPromise.Reject<any>):void\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tswitch(this.state)\r\n\t\t{\r\n\t\t\tcase TSDNPromise.State.Fulfilled:\r\n\t\t\t\tif(onFulfilled) onFulfilled(this._result!);\r\n\t\t\t\tbreak;\r\n\t\t\tcase TSDNPromise.State.Rejected:\r\n\t\t\t\tif(onRejected) onRejected(this._error);\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tthenSynchronous<TFulfilled = T, TRejected = never>(\r\n\t\tonFulfilled:TSDNPromise.Fulfill<T, TFulfilled>,\r\n\t\tonRejected?:TSDNPromise.Reject<TRejected>):PromiseBase<TFulfilled | TRejected>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\tswitch(this.state)\r\n\t\t\t{\r\n\t\t\t\tcase TSDNPromise.State.Fulfilled:\r\n\t\t\t\t\treturn onFulfilled\r\n\t\t\t\t\t\t? resolve(this._result, onFulfilled, TSDNPromise.resolve)\r\n\t\t\t\t\t\t: <any>this; // Provided for catch cases.\r\n\t\t\t\tcase TSDNPromise.State.Rejected:\r\n\t\t\t\t\treturn onRejected\r\n\t\t\t\t\t\t? resolve(this._error, onRejected, TSDNPromise.resolve)\r\n\t\t\t\t\t\t: <any>this;\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch(ex)\r\n\t\t{\r\n\t\t\treturn new Rejected<any>(ex);\r\n\t\t}\r\n\r\n\t\tthrow new Error(\"Invalid state for a resolved promise.\");\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * The simplest usable version of a promise which returns synchronously the resolved state provided.\r\n */\r\nexport abstract class Resolved<T>\r\n\textends Resolvable<T>\r\n{\r\n\tconstructor(state:TSDNPromise.State, result:T, error?:any)\r\n\t{\r\n\t\tsuper();\r\n\t\tthis._result = result;\r\n\t\tthis._error = error;\r\n\t\tthis._state = state;\r\n\t}\r\n\r\n\r\n}\r\n\r\n/**\r\n * A fulfilled Resolved<T>.  Provided for readability.\r\n */\r\nexport class Fulfilled<T>\r\n\textends Resolved<T>\r\n{\r\n\tconstructor(value:T)\r\n\t{\r\n\t\tsuper(TSDNPromise.State.Fulfilled, value);\r\n\t}\r\n}\r\n\r\n/**\r\n * A rejected Resolved<T>.  Provided for readability.\r\n */\r\nexport class Rejected<T>\r\n\textends Resolved<T>\r\n{\r\n\tconstructor(error:any)\r\n\t{\r\n\t\tsuper(TSDNPromise.State.Rejected, VOID0, error);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * Provided as a means for extending the interface of other PromiseLike<T> objects.\r\n */\r\nclass PromiseWrapper<T>\r\n\textends Resolvable<T>\r\n{\r\n\tconstructor(private _target:PromiseLike<T>)\r\n\t{\r\n\t\tsuper();\r\n\r\n\t\tif(!_target)\r\n\t\t\tthrow new ArgumentNullException(TARGET);\r\n\r\n\t\tif(!isPromise(_target))\r\n\t\t\tthrow new ArgumentException(TARGET, \"Must be a promise-like object.\");\r\n\r\n\t\t_target.then(\r\n\t\t\t(v:T) => {\r\n\t\t\t\tthis._state = TSDNPromise.State.Fulfilled;\r\n\t\t\t\tthis._result = v;\r\n\t\t\t\tthis._error = VOID0;\r\n\t\t\t\tthis._target = VOID0;\r\n\t\t\t},\r\n\t\t\te => {\r\n\t\t\t\tthis._state = TSDNPromise.State.Rejected;\r\n\t\t\t\tthis._error = e;\r\n\t\t\t\tthis._target = VOID0;\r\n\t\t\t})\r\n\t}\r\n\r\n\tthenSynchronous<TFulfilled = T, TRejected = never>(\r\n\t\tonFulfilled:TSDNPromise.Fulfill<T, TFulfilled>,\r\n\t\tonRejected?:TSDNPromise.Reject<TRejected>):PromiseBase<TFulfilled | TRejected>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tlet t = this._target;\r\n\t\tif(!t) return super.thenSynchronous(onFulfilled, onRejected);\r\n\r\n\t\treturn new TSDNPromise<TFulfilled | TRejected>((resolve, reject) => {\r\n\t\t\thandleDispatch(t,\r\n\t\t\t\tresult => handleResolutionMethods(resolve, reject, result, onFulfilled),\r\n\t\t\t\terror => onRejected\r\n\t\t\t\t\t? handleResolutionMethods(resolve, null, error, onRejected)\r\n\t\t\t\t\t: reject(error)\r\n\t\t\t);\r\n\t\t}, true);\r\n\t}\r\n\r\n\tdoneNow(\r\n\t\tonFulfilled:TSDNPromise.Fulfill<T, any>,\r\n\t\tonRejected?:TSDNPromise.Reject<any>):void\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tlet t = this._target;\r\n\t\tif(t)\r\n\t\t\thandleDispatch(t, onFulfilled, onRejected);\r\n\t\telse\r\n\t\t\tsuper.doneNow(onFulfilled, onRejected);\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis._target = VOID0;\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * This promise class that facilitates pending resolution.\r\n */\r\nexport class TSDNPromise<T>\r\n\textends Resolvable<T>\r\n{\r\n\r\n\tprivate _waiting:IPromiseCallbacks<any>[] | null | undefined;\r\n\r\n\t/*\r\n\t * A note about deferring:\r\n\t * The caller can set resolveImmediate to true if they intend to initialize code that will end up being deferred itself.\r\n\t * This eliminates the extra defer that will occur internally.\r\n\t * But for the most part, resolveImmediate = false (the default) will ensure the constructor will not block.\r\n\t *\r\n\t * resolveUsing allows for the same ability but does not defer by default: allowing the caller to take on the work load.\r\n\t * If calling resolve or reject and a deferred response is desired, then use deferImmediate with a closure to do so.\r\n\t */\r\n\r\n\tconstructor(\r\n\t\tresolver?:TSDNPromise.Executor<T>, forceSynchronous:boolean = false)\r\n\t{\r\n\t\tsuper();\r\n\r\n\t\tif(resolver) this.resolveUsing(resolver, forceSynchronous);\r\n\t}\r\n\r\n\tthenSynchronous<TFulfilled = T, TRejected = never>(\r\n\t\tonFulfilled:TSDNPromise.Fulfill<T, TFulfilled>,\r\n\t\tonRejected?:TSDNPromise.Reject<TRejected>):PromiseBase<TFulfilled | TRejected>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\t// Already fulfilled?\r\n\t\tif(this._state) return super.thenSynchronous(onFulfilled, onRejected);\r\n\r\n\t\tconst p = new TSDNPromise<TFulfilled | TRejected>();\r\n\t\t(this._waiting || (this._waiting = []))\r\n\t\t\t.push(Pool.init(onFulfilled, onRejected, p));\r\n\t\treturn p;\r\n\t}\r\n\r\n\tdoneNow(\r\n\t\tonFulfilled:TSDNPromise.Fulfill<T, any>,\r\n\t\tonRejected?:TSDNPromise.Reject<any>):void\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\t// Already fulfilled?\r\n\t\tif(this._state)\r\n\t\t\treturn super.doneNow(onFulfilled, onRejected);\r\n\r\n\t\t(this._waiting || (this._waiting = []))\r\n\t\t\t.push(Pool.init(onFulfilled, onRejected));\r\n\t}\r\n\r\n\tprotected _onDispose()\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis._resolvedCalled = VOID0;\r\n\t}\r\n\r\n\t// Protects against double calling.\r\n\t// @ts-ignore;\r\n\tprotected _resolvedCalled:boolean;\r\n\r\n\tresolveUsing(\r\n\t\tresolver:TSDNPromise.Executor<T>,\r\n\t\tforceSynchronous:boolean = false):void\r\n\t{\r\n\t\tif(!resolver)\r\n\t\t\tthrow new ArgumentNullException(\"resolver\");\r\n\t\tif(this._resolvedCalled)\r\n\t\t\tthrow new InvalidOperationException(\".resolve() already called.\");\r\n\t\tif(this.state)\r\n\t\t\tthrow new InvalidOperationException(\"Already resolved: \" + TSDNPromise.State[this.state]);\r\n\r\n\t\tthis._resolvedCalled = true;\r\n\r\n\t\tlet state = 0;\r\n\t\tconst rejectHandler = (reason:any) => {\r\n\t\t\tif(state)\r\n\t\t\t{\r\n\t\t\t\t// Someone else's promise handling down stream could double call this. :\\\r\n\t\t\t\tconsole.warn(state== -1\r\n\t\t\t\t\t? \"Rejection called multiple times\"\r\n\t\t\t\t\t: \"Rejection called after fulfilled.\");\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tstate = -1;\r\n\t\t\t\tthis._resolvedCalled = false;\r\n\t\t\t\tthis.reject(reason);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tconst fulfillHandler = (v:any) => {\r\n\t\t\tif(state)\r\n\t\t\t{\r\n\t\t\t\t// Someone else's promise handling down stream could double call this. :\\\r\n\t\t\t\tconsole.warn(state==1\r\n\t\t\t\t\t? \"Fulfill called multiple times\"\r\n\t\t\t\t\t: \"Fulfill called after rejection.\");\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tstate = 1;\r\n\t\t\t\tthis._resolvedCalled = false;\r\n\t\t\t\tthis.resolve(v);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// There are some performance edge cases where there caller is not blocking upstream and does not need to defer.\r\n\t\tif(forceSynchronous)\r\n\t\t\tresolver(fulfillHandler, rejectHandler);\r\n\t\telse\r\n\t\t\tdeferImmediate(() => resolver(fulfillHandler, rejectHandler));\r\n\r\n\t}\r\n\r\n\r\n\tprivate _emitDisposalRejection(p:PromiseBase<any>):boolean\r\n\t{\r\n\t\tconst d = p.wasDisposed;\r\n\t\tif(d) this._rejectInternal(newODE());\r\n\t\treturn d;\r\n\t}\r\n\r\n\tprivate _resolveInternal(result?:T | PromiseLike<T>):void\r\n\t{\r\n\t\tif(this.wasDisposed) return;\r\n\r\n\t\t// Note: Avoid recursion if possible.\r\n\r\n\t\t// Check ahead of time for resolution and resolve appropriately\r\n\t\twhile(result instanceof PromiseBase)\r\n\t\t{\r\n\t\t\tlet r:PromiseBase<T> = <any>result;\r\n\t\t\tif(this._emitDisposalRejection(r)) return;\r\n\t\t\tswitch(r.state)\r\n\t\t\t{\r\n\t\t\t\tcase TSDNPromise.State.Pending:\r\n\t\t\t\t\tr.doneNow(\r\n\t\t\t\t\t\tv => this._resolveInternal(v),\r\n\t\t\t\t\t\te => this._rejectInternal(e)\r\n\t\t\t\t\t);\r\n\t\t\t\t\treturn;\r\n\t\t\t\tcase TSDNPromise.State.Rejected:\r\n\t\t\t\t\tthis._rejectInternal(r.error);\r\n\t\t\t\t\treturn;\r\n\t\t\t\tcase TSDNPromise.State.Fulfilled:\r\n\t\t\t\t\tresult = r.result;\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(isPromise(result))\r\n\t\t{\r\n\t\t\tresult.then(\r\n\t\t\t\tv => this._resolveInternal(v),\r\n\t\t\t\te => this._rejectInternal(e)\r\n\t\t\t);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis._state = TSDNPromise.State.Fulfilled;\r\n\r\n\t\t\tthis._result = result;\r\n\t\t\tthis._error = VOID0;\r\n\t\t\tconst o = this._waiting;\r\n\t\t\tif(o)\r\n\t\t\t{\r\n\t\t\t\tthis._waiting = VOID0;\r\n\t\t\t\tfor(let c of o)\r\n\t\t\t\t{\r\n\t\t\t\t\tlet {onFulfilled, promise} = c;\r\n\t\t\t\t\tPool.recycle(c);\r\n\t\t\t\t\t//let ex =\r\n\t\t\t\t\thandleResolution(<any>promise, result, onFulfilled);\r\n\t\t\t\t\t//if(!p && ex) console.error(\"Unhandled exception in onFulfilled:\",ex);\r\n\t\t\t\t}\r\n\t\t\t\to.length = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprivate _rejectInternal(error:any):void\r\n\t{\r\n\r\n\t\tif(this.wasDisposed) return;\r\n\r\n\t\tthis._state = TSDNPromise.State.Rejected;\r\n\r\n\t\tthis._error = error;\r\n\t\tconst o = this._waiting;\r\n\t\tif(o)\r\n\t\t{\r\n\t\t\tthis._waiting = null; // null = finished. undefined = hasn't started.\r\n\t\t\tfor(let c of o)\r\n\t\t\t{\r\n\t\t\t\tlet {onRejected, promise} = c;\r\n\t\t\t\tPool.recycle(c);\r\n\t\t\t\tif(onRejected)\r\n\t\t\t\t{\r\n\t\t\t\t\t//let ex =\r\n\t\t\t\t\thandleResolution(promise, error, onRejected);\r\n\t\t\t\t\t//if(!p && ex) console.error(\"Unhandled exception in onRejected:\",ex);\r\n\t\t\t\t}\r\n\t\t\t\telse if(promise)\r\n\t\t\t\t{ //noinspection JSIgnoredPromiseFromCall\r\n\t\t\t\t\tpromise.reject(error);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\to.length = 0;\r\n\t\t}\r\n\t}\r\n\r\n\tresolve(result?:T | PromiseLike<T>, throwIfSettled:boolean = false):void\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\tif(<any>result==this)\r\n\t\t\tthrow new InvalidOperationException(\"Cannot resolve a promise as itself.\");\r\n\r\n\t\tif(this._state)\r\n\t\t{\r\n\t\t\t// Same value? Ignore...\r\n\t\t\tif(!throwIfSettled || this._state==TSDNPromise.State.Fulfilled && this._result===result) return;\r\n\t\t\tthrow new InvalidOperationException(\"Changing the fulfilled state/value of a promise is not supported.\");\r\n\t\t}\r\n\r\n\t\tif(this._resolvedCalled)\r\n\t\t{\r\n\t\t\tif(throwIfSettled)\r\n\t\t\t\tthrow new InvalidOperationException(\".resolve() already called.\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._resolveInternal(result);\r\n\t}\r\n\r\n\r\n\treject(error:any, throwIfSettled:boolean = false):void\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\tif(this._state)\r\n\t\t{\r\n\t\t\t// Same value? Ignore...\r\n\t\t\tif(!throwIfSettled || this._state==TSDNPromise.State.Rejected && this._error===error) return;\r\n\t\t\tthrow new InvalidOperationException(\"Changing the rejected state/value of a promise is not supported.\");\r\n\t\t}\r\n\r\n\t\tif(this._resolvedCalled)\r\n\t\t{\r\n\t\t\tif(throwIfSettled)\r\n\t\t\t\tthrow new InvalidOperationException(\".resolve() already called.\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._rejectInternal(error);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * By providing an ArrayPromise we expose useful methods/shortcuts for dealing with array results.\r\n */\r\nexport class ArrayPromise<T>\r\n\textends TSDNPromise<T[]>\r\n{\r\n\r\n\t/**\r\n\t * Simplifies the use of a map function on an array of results when the source is assured to be an array.\r\n\t * @param transform\r\n\t * @returns {PromiseBase<Array<any>>}\r\n\t */\r\n\tmap<U>(transform:(value:T) => U):ArrayPromise<U>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn new ArrayPromise<U>(resolve => {\r\n\t\t\tthis.doneNow(result => resolve(result.map(transform)));\r\n\t\t}, true);\r\n\t}\r\n\r\n\treduce(\r\n\t\treduction:(previousValue:T, currentValue:T, i?:number, array?:T[]) => T,\r\n\t\tinitialValue?:T):PromiseBase<T>\r\n\r\n\treduce<U>(\r\n\t\treduction:(previousValue:U, currentValue:T, i?:number, array?:T[]) => U,\r\n\t\tinitialValue:U):PromiseBase<U>\r\n\r\n\t/**\r\n\t * Simplifies the use of a reduce function on an array of results when the source is assured to be an array.\r\n\t * @param reduction\r\n\t * @param initialValue\r\n\t * @returns {PromiseBase<any>}\r\n\t */\r\n\treduce<U>(\r\n\t\treduction:(previousValue:U, currentValue:T, i?:number, array?:T[]) => U,\r\n\t\tinitialValue?:U):PromiseBase<U>\r\n\t{\r\n\r\n\t\treturn this\r\n\t\t\t.thenSynchronous(result => result.reduce(reduction, <any>initialValue));\r\n\t}\r\n\r\n\tstatic fulfilled<T>(value:T[]):ArrayPromise<T>\r\n\t{\r\n\t\treturn new ArrayPromise<T>(resolve => value, true);\r\n\t}\r\n}\r\n\r\nconst PROMISE_COLLECTION = \"PromiseCollection\";\r\n\r\n/**\r\n * A Promise collection exposes useful methods for handling a collection of promises and their results.\r\n */\r\nexport class PromiseCollection<T>\r\n\textends DisposableBase\r\n{\r\n\tprivate _source:PromiseLike<T>[];\r\n\r\n\tconstructor(source:PromiseLike<T>[] | null | undefined)\r\n\t{\r\n\t\tsuper(PROMISE_COLLECTION);\r\n\t\tthis._source = source && source.slice() || [];\r\n\t}\r\n\r\n\tprotected _onDispose()\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis._source.length = 0;\r\n\t\t(<any>this)._source = null;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a copy of the source promises.\r\n\t * @returns {PromiseLike<PromiseLike<any>>[]}\r\n\t */\r\n\tget promises():PromiseLike<T>[]\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn this._source.slice();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, or is rejected with the same rejection reason as the first promise to be rejected.\r\n\t * @returns {PromiseBase<any>}\r\n\t */\r\n\tall():ArrayPromise<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn TSDNPromise.all(this._source);\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\r\n\t * or rejected.\r\n\t * @returns {PromiseBase<any>} A new Promise.\r\n\t */\r\n\trace():PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn TSDNPromise.race(this._source);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a promise that is fulfilled with array of provided promises when all provided promises have resolved (fulfill or reject).\r\n\t * Unlike .all this method waits for all rejections as well as fulfillment.\r\n\t * @returns {PromiseBase<PromiseLike<any>[]>}\r\n\t */\r\n\twaitAll():ArrayPromise<PromiseLike<T>>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn TSDNPromise.waitAll(this._source);\r\n\t}\r\n\r\n\t/**\r\n\t * Waits for all the values to resolve and then applies a transform.\r\n\t * @param transform\r\n\t * @returns {PromiseBase<Array<any>>}\r\n\t */\r\n\tmap<U>(transform:(value:T) => U):ArrayPromise<U>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn new ArrayPromise<U>(resolve => {\r\n\t\t\tthis.all()\r\n\t\t\t\t.doneNow(result => resolve(result.map(transform)));\r\n\t\t}, true);\r\n\t}\r\n\r\n\t/**\r\n\t * Applies a transform to each promise and defers the result.\r\n\t * Unlike map, this doesn't wait for all promises to resolve, ultimately improving the async nature of the request.\r\n\t * @param transform\r\n\t * @returns {PromiseCollection<U>}\r\n\t */\r\n\r\n\tpipe<U>(transform:(value:T) => U | PromiseLike<U>):PromiseCollection<U>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn new PromiseCollection<U>(\r\n\t\t\tthis._source.map(p => handleSyncIfPossible(p, transform))\r\n\t\t);\r\n\t}\r\n\r\n\treduce(\r\n\t\treduction:(previousValue:T, currentValue:T, i?:number, array?:PromiseLike<T>[]) => T,\r\n\t\tinitialValue?:T | PromiseLike<T>):PromiseBase<T>\r\n\r\n\treduce<U>(\r\n\t\treduction:(previousValue:U, currentValue:T, i?:number, array?:PromiseLike<T>[]) => U,\r\n\t\tinitialValue:U | PromiseLike<U>):PromiseBase<U>\r\n\r\n\t/**\r\n\t * Behaves like array reduce.\r\n\t * Creates the promise chain necessary to produce the desired result.\r\n\t * @param reduction\r\n\t * @param initialValue\r\n\t * @returns {PromiseBase<PromiseLike<any>>}\r\n\t */\r\n\treduce<U>(\r\n\t\treduction:(previousValue:U, currentValue:T, i?:number, array?:PromiseLike<T>[]) => U,\r\n\t\tinitialValue?:U | PromiseLike<U>):PromiseBase<U>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn TSDNPromise.wrap<U>(this._source\r\n\t\t\t.reduce(\r\n\t\t\t\t(\r\n\t\t\t\t\tprevious:PromiseLike<U>,\r\n\t\t\t\t\tcurrent:PromiseLike<T>,\r\n\t\t\t\t\ti:number,\r\n\t\t\t\t\tarray:PromiseLike<T>[]) =>\r\n\t\t\t\t\thandleSyncIfPossible(previous,\r\n\t\t\t\t\t\t(p:U) => handleSyncIfPossible(current, (c:T) => reduction(p, c, i, array))),\r\n\r\n\t\t\t\tisPromise(initialValue)\r\n\t\t\t\t\t? initialValue\r\n\t\t\t\t\t: new Fulfilled(<any>initialValue)\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n}\r\n\r\nmodule Pool\r\n{\r\n\r\n\tlet pool:ObjectPool<IPromiseCallbacks<any>>;\r\n\r\n\t//noinspection JSUnusedLocalSymbols\r\n\tfunction getPool()\r\n\t{\r\n\t\treturn pool\r\n\t\t\t|| (pool = new ObjectPool<IPromiseCallbacks<any>>(40, factory, c => {\r\n\t\t\t\tc.onFulfilled = NULL;\r\n\t\t\t\tc.onRejected = NULL;\r\n\t\t\t\tc.promise = NULL;\r\n\t\t\t}));\r\n\t}\r\n\r\n\tfunction factory():IPromiseCallbacks<any>\r\n\t{\r\n\t\treturn {\r\n\t\t\tonFulfilled: NULL,\r\n\t\t\tonRejected: NULL,\r\n\t\t\tpromise: NULL\r\n\t\t}\r\n\t}\r\n\r\n\texport function init<T>(\r\n\t\tonFulfilled:TSDNPromise.Fulfill<T, any>,\r\n\t\tonRejected?:TSDNPromise.Reject<any>,\r\n\t\tpromise?:TSDNPromise<any>):IPromiseCallbacks<T>\r\n\t{\r\n\r\n\t\tconst c = getPool().take();\r\n\t\tc.onFulfilled = onFulfilled || undefined;\r\n\t\tc.onRejected = onRejected || undefined;\r\n\t\tc.promise = promise;\r\n\t\treturn c;\r\n\t}\r\n\r\n\texport function recycle<T>(c:IPromiseCallbacks<T>):void\r\n\t{\r\n\t\tgetPool().add(c);\r\n\t}\r\n}\r\n\r\n\r\nexport module TSDNPromise\r\n{\r\n\r\n\t/**\r\n\t * The state of a promise.\r\n\t * https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md\r\n\t * If a promise is disposed the value will be undefined which will also evaluate (promise.state)==false.\r\n\t */\r\n\texport enum State\r\n\t{\r\n\t\tPending   = 0,\r\n\t\tFulfilled = 1,\r\n\t\tRejected  = -1\r\n\t}\r\n\r\n\tObject.freeze(State);\r\n\r\n\texport type Resolution<TResult> = TResult | PromiseLike<TResult>;\r\n\r\n\texport type Fulfill<T, TResult> = Selector<T, Resolution<TResult>> | null | undefined;\r\n\r\n\texport type Reject<TResult> = Selector<any, Resolution<TResult>> | null | undefined;\r\n\r\n\texport interface Then<T, TResult>\r\n\t{\r\n\t\t(onfulfilled?:Fulfill<T, TResult>, onrejected?:Reject<TResult>):PromiseLike<TResult>;\r\n\r\n\t\t(onfulfilled?:Fulfill<T, TResult>, onrejected?:Reject<void>):PromiseLike<TResult>;\r\n\t}\r\n\r\n\texport interface Executor<T>\r\n\t{\r\n\t\t(\r\n\t\t\tresolve:(value?:T | PromiseLike<T>) => void,\r\n\t\t\treject:(reason?:any) => void):void;\r\n\t}\r\n\r\n\t//noinspection JSUnusedGlobalSymbols\r\n\texport interface Factory\r\n\t{\r\n\t\t<T>(executor:Executor<T>):PromiseLike<T>;\r\n\t}\r\n\r\n\texport function factory<T>(e:Executor<T>):TSDNPromise<T>\r\n\t{\r\n\t\treturn new TSDNPromise(e);\r\n\t}\r\n\r\n\t/**\r\n\t * Takes a set of promises and returns a PromiseCollection.\r\n\t * @param promises\r\n\t */\r\n\texport function group<T>(promises:PromiseLike<T>[]):PromiseCollection<T>\r\n\texport function group<T>(\r\n\t\tpromise:PromiseLike<T>,\r\n\t\t...rest:PromiseLike<T>[]):PromiseCollection<T>\r\n\texport function group(\r\n\t\tfirst:PromiseLike<any> | PromiseLike<any>[],\r\n\t\t...rest:PromiseLike<any>[]):PromiseCollection<any>\r\n\t{\r\n\r\n\t\tif(!first && !rest.length) throw new ArgumentNullException(\"promises\");\r\n\t\treturn new PromiseCollection(\r\n\t\t\t((first) instanceof (Array) ? first : [first])\r\n\t\t\t\t.concat(rest)\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, or is rejected with the same rejection reason as the first promise to be rejected.\r\n\t */\r\n\texport function all<T>(promises:PromiseLike<T>[]):ArrayPromise<T>\r\n\texport function all<T>(promise:PromiseLike<T>, ...rest:PromiseLike<T>[]):ArrayPromise<T>\r\n\texport function all(\r\n\t\tfirst:PromiseLike<any> | PromiseLike<any>[],\r\n\t\t...rest:PromiseLike<any>[]):ArrayPromise<any>\r\n\t{\r\n\t\tif(!first && !rest.length) throw new ArgumentNullException(\"promises\");\r\n\t\tlet promises = ((first) instanceof (Array) ? first : [first]).concat(rest); // yay a copy!\r\n\t\tif(!promises.length || promises.every(v => !v)) return new ArrayPromise<any>(\r\n\t\t\tr => r(promises), true); // it's a new empty, reuse it. :|\r\n\r\n\t\t// Eliminate deferred and take the parent since all .then calls happen on next cycle anyway.\r\n\t\treturn new ArrayPromise<any>((resolve, reject) => {\r\n\t\t\tlet result:any[] = [];\r\n\t\t\tlet len = promises.length;\r\n\t\t\tresult.length = len;\r\n\t\t\t// Using a set instead of -- a number is more reliable if just in case one of the provided promises resolves twice.\r\n\t\t\tlet remaining = new Set(promises.map((v, i) => i)); // get all the indexes...\r\n\r\n\t\t\tlet cleanup = () => {\r\n\t\t\t\treject = VOID0;\r\n\t\t\t\tresolve = VOID0;\r\n\t\t\t\tpromises.length = 0;\r\n\t\t\t\tpromises = VOID0;\r\n\t\t\t\tremaining.dispose();\r\n\t\t\t\tremaining = VOID0;\r\n\t\t\t};\r\n\r\n\t\t\tlet checkIfShouldResolve = () => {\r\n\t\t\t\tlet r = resolve;\r\n\t\t\t\tif(r && !remaining.count)\r\n\t\t\t\t{\r\n\t\t\t\t\tcleanup();\r\n\t\t\t\t\tr(result);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tlet onFulfill = (v:any, i:number) => {\r\n\t\t\t\tif(resolve)\r\n\t\t\t\t{\r\n\t\t\t\t\tresult[i] = v;\r\n\t\t\t\t\tremaining.remove(i);\r\n\t\t\t\t\tcheckIfShouldResolve();\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tlet onReject = (e?:any) => {\r\n\t\t\t\tlet r = reject;\r\n\t\t\t\tif(r)\r\n\t\t\t\t{\r\n\t\t\t\t\tcleanup();\r\n\t\t\t\t\tr(e);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tfor(let i = 0; remaining && i<len; i++)\r\n\t\t\t{\r\n\t\t\t\tlet p = promises[i];\r\n\t\t\t\tif(p) p.then(v => onFulfill(v, i), onReject);\r\n\t\t\t\telse remaining.remove(i);\r\n\t\t\t\tcheckIfShouldResolve();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a promise that is fulfilled with array of provided promises when all provided promises have resolved (fulfill or reject).\r\n\t * Unlike .all this method waits for all rejections as well as fulfillment.\r\n\t */\r\n\texport function waitAll<T>(promises:PromiseLike<T>[]):ArrayPromise<PromiseLike<T>>\r\n\texport function waitAll<T>(\r\n\t\tpromise:PromiseLike<T>,\r\n\t\t...rest:PromiseLike<T>[]):ArrayPromise<PromiseLike<T>>\r\n\texport function waitAll(\r\n\t\tfirst:PromiseLike<any> | PromiseLike<any>[],\r\n\t\t...rest:PromiseLike<any>[]):ArrayPromise<PromiseLike<any>>\r\n\t{\r\n\t\tif(!first && !rest.length) throw new ArgumentNullException(\"promises\");\r\n\t\tconst promises = ((first) instanceof (Array) ? first : [first]).concat(rest); // yay a copy!\r\n\t\tif(!promises.length || promises.every(v => !v)) return new ArrayPromise<any>(\r\n\t\t\tr => r(promises), true); // it's a new empty, reuse it. :|\r\n\r\n\r\n\t\t// Eliminate deferred and take the parent since all .then calls happen on next cycle anyway.\r\n\t\treturn new ArrayPromise<any>((resolve, reject) => {\r\n\t\t\tlet len = promises.length;\r\n\r\n\t\t\t// Using a set instead of -- a number is more reliable if just in case one of the provided promises resolves twice.\r\n\t\t\tlet remaining = new Set(promises.map((v, i) => i)); // get all the indexes...\r\n\r\n\t\t\tlet cleanup = () => {\r\n\t\t\t\treject = NULL;\r\n\t\t\t\tresolve = NULL;\r\n\t\t\t\tremaining.dispose();\r\n\t\t\t\tremaining = NULL;\r\n\t\t\t};\r\n\r\n\t\t\tlet checkIfShouldResolve = () => {\r\n\t\t\t\tlet r = resolve;\r\n\t\t\t\tif(r && !remaining.count)\r\n\t\t\t\t{\r\n\t\t\t\t\tcleanup();\r\n\t\t\t\t\tr(promises);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tlet onResolved = (i:number) => {\r\n\t\t\t\tif(remaining)\r\n\t\t\t\t{\r\n\t\t\t\t\tremaining.remove(i);\r\n\t\t\t\t\tcheckIfShouldResolve();\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tfor(let i = 0; remaining && i<len; i++)\r\n\t\t\t{\r\n\t\t\t\tlet p = promises[i];\r\n\t\t\t\tif(p) p.then(v => onResolved(i), e => onResolved(i));\r\n\t\t\t\telse onResolved(i);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\r\n\t * or rejected.\r\n\t * @param promises An array of Promises.\r\n\t * @returns A new Promise.\r\n\t */\r\n\texport function race<T>(promises:PromiseLike<T>[]):PromiseBase<T>\r\n\texport function race<T>(promise:PromiseLike<T>, ...rest:PromiseLike<T>[]):PromiseBase<T>\r\n\texport function race(\r\n\t\tfirst:PromiseLike<any> | PromiseLike<any>[],\r\n\t\t...rest:PromiseLike<any>[]):PromiseBase<any>\r\n\t{\r\n\t\tlet promises = first && ((first) instanceof (Array) ? first : [first]).concat(rest); // yay a copy?\r\n\t\tif(!promises || !promises.length || !(promises = promises.filter(v => v!=null)).length)\r\n\t\t\tthrow new ArgumentException(\"Nothing to wait for.\");\r\n\r\n\t\tconst len = promises.length;\r\n\r\n\t\t// Only one?  Nothing to race.\r\n\t\tif(len==1) return wrap(promises[0]);\r\n\r\n\t\t// Look for already resolved promises and the first one wins.\r\n\t\tfor(let i = 0; i<len; i++)\r\n\t\t{\r\n\t\t\tconst p:any = promises[i];\r\n\t\t\tif(p instanceof PromiseBase && p.isSettled) return p;\r\n\t\t}\r\n\r\n\t\treturn new TSDNPromise((resolve, reject) => {\r\n\t\t\tlet cleanup = () => {\r\n\t\t\t\treject = NULL;\r\n\t\t\t\tresolve = NULL;\r\n\t\t\t\tpromises.length = 0;\r\n\t\t\t\tpromises = NULL;\r\n\t\t\t};\r\n\r\n\t\t\tlet onResolve = (r:(x:any) => void, v:any) => {\r\n\t\t\t\tif(r)\r\n\t\t\t\t{\r\n\t\t\t\t\tcleanup();\r\n\t\t\t\t\tr(v);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tlet onFulfill = (v:any) => onResolve(resolve, v);\r\n\t\t\tlet onReject = (e?:any) => onResolve(reject, e);\r\n\r\n\t\t\tfor(let p of promises)\r\n\t\t\t{\r\n\t\t\t\tif(!resolve) break;\r\n\t\t\t\tp.then(onFulfill, onReject);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t// // race<T>(values: Iterable<T | PromiseLike<T>>): Promise<T>;\r\n\r\n\t/**\r\n\t * Creates a new resolved promise .\r\n\t * @returns A resolved promise.\r\n\t */\r\n\texport function resolve():PromiseBase<void>\r\n\r\n\t/**\r\n\t * Creates a new resolved promise for the provided value.\r\n\t * @param value A value or promise.\r\n\t * @returns A promise whose internal state matches the provided promise.\r\n\t */\r\n\texport function resolve<T>(value:T | PromiseLike<T>):PromiseBase<T>;\r\n\texport function resolve(value?:any):PromiseBase<any>\r\n\t{\r\n\r\n\t\treturn isPromise(value) ? wrap(value) : new Fulfilled(value);\r\n\t}\r\n\r\n\t/**\r\n\t * Syntactic shortcut for avoiding 'new'.\r\n\t * @param resolver\r\n\t * @param forceSynchronous\r\n\t * @returns {TSDNPromise}\r\n\t */\r\n\texport function using<T>(\r\n\t\tresolver:TSDNPromise.Executor<T>,\r\n\t\tforceSynchronous:boolean = false):PromiseBase<T>\r\n\t{\r\n\t\treturn new TSDNPromise<T>(resolver, forceSynchronous);\r\n\t}\r\n\r\n\t/**\r\n\t * Takes a set of values or promises and returns a PromiseCollection.\r\n\t * Similar to 'group' but calls resolve on each entry.\r\n\t * @param resolutions\r\n\t */\r\n\texport function resolveAll<T>(resolutions:Array<T | PromiseLike<T>>):PromiseCollection<T>;\r\n\texport function resolveAll<T>(\r\n\t\tpromise:T | PromiseLike<T>,\r\n\t\t...rest:Array<T | PromiseLike<T>>):PromiseCollection<T>\r\n\texport function resolveAll(\r\n\t\tfirst:any | PromiseLike<any> | Array<any | PromiseLike<any>>,\r\n\t\t...rest:Array<any | PromiseLike<any>>):PromiseCollection<any>\r\n\t{\r\n\t\tif(!first && !rest.length) throw new ArgumentNullException(\"resolutions\");\r\n\t\treturn new PromiseCollection(\r\n\t\t\t((first) instanceof (Array) ? first : [first])\r\n\t\t\t\t.concat(rest)\r\n\t\t\t\t.map((v:any) => resolve(v)));\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a PromiseCollection containing promises that will resolve on the next tick using the transform function.\r\n\t * This utility function does not chain promises together to create the result,\r\n\t * it only uses one promise per transform.\r\n\t * @param source\r\n\t * @param transform\r\n\t * @returns {PromiseCollection<T>}\r\n\t */\r\n\texport function map<T, U>(source:T[], transform:(value:T) => U):PromiseCollection<U>\r\n\t{\r\n\t\treturn new PromiseCollection<U>(\r\n\t\t\tsource.map(d => new TSDNPromise<U>((r, j) => {\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\tr(transform(d));\r\n\t\t\t\t}\r\n\t\t\t\tcatch(ex)\r\n\t\t\t\t{\r\n\t\t\t\t\tj(ex);\r\n\t\t\t\t}\r\n\t\t\t}))\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a new rejected promise for the provided reason.\r\n\t * @param reason The reason the promise was rejected.\r\n\t * @returns A new rejected Promise.\r\n\t */\r\n\texport function reject<T>(reason:T):PromiseBase<T>\r\n\t{\r\n\t\treturn new Rejected<T>(reason);\r\n\t}\r\n\r\n\t/**\r\n\t * Takes any Promise-Like object and ensures an extended version of it from this module.\r\n\t * @param target The Promise-Like object\r\n\t * @returns A new target that simply extends the target.\r\n\t */\r\n\texport function wrap<T>(target:T | PromiseLike<T>):PromiseBase<T>\r\n\t{\r\n\t\tif(!target) throw new ArgumentNullException(TARGET);\r\n\t\treturn isPromise(target)\r\n\t\t\t? (target instanceof PromiseBase ? target : new PromiseWrapper(target))\r\n\t\t\t: new Fulfilled<T>(target);\r\n\t}\r\n\r\n\t/**\r\n\t * A function that acts like a 'then' method (aka then-able) can be extended by providing a function that takes an onFulfill and onReject.\r\n\t * @param then\r\n\t * @returns {PromiseWrapper<T>}\r\n\t */\r\n\texport function createFrom<T>(then:Then<T, any>):PromiseBase<T>\r\n\t{\r\n\t\tif(!then) throw new ArgumentNullException(THEN);\r\n\t\treturn new PromiseWrapper<T>({then: then});\r\n\t}\r\n\r\n}\r\n\r\n\r\ninterface IPromiseCallbacks<T>\r\n{\r\n\tonFulfilled?:TSDNPromise.Fulfill<T, any>;\r\n\tonRejected?:TSDNPromise.Reject<any>;\r\n\tpromise?:TSDNPromise<any>;\r\n}\r\n\r\nexport {TSDNPromise as Promise};\r\n\r\nexport default TSDNPromise;\r\n\r\n\r\n"]}