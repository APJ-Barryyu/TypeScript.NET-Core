{"version":3,"sources":["System/Events/EventDispatcherBase.js","System/Events/EventDispatcherBase.ts"],"names":["define","require","exports","AU","shallowCopy_1","DisposableBase_1","dispose_1","EventDispatcherEntry_1","extends_1","entryFinalizer","_","this","p","params","d","dispatcher","removeEntry","Object","defineProperty","value","__extends","DISPOSING","DISPOSED","NAME","EventDispatcherBase","_super","_this","call","_isDisposing","_disposableObjectName","prototype","addEventListener","type","listener","priority","e","_entries","push","EventDispatcherEntry","entry","remove","registerEventListener","hasEventListener","some","removeEventListener","dispose","these","noCopy","filter","matches","dispatchEvent","l","length","event","Event","create","cancellable","target","entries","sort","a","b","forEach","newEvent","shallowCopy","dispatch","get","enumerable","configurable","wasDisposed","DisposableBase"],"mappings":"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","file":"EventDispatcherBase.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\ndefine([\"require\", \"exports\", \"../Collections/Array/Utility\", \"../Utility/shallowCopy\", \"../Disposable/DisposableBase\", \"../Disposable/dispose\", \"./EventDispatcherEntry\", \"../../extends\"], function (require, exports, AU, shallowCopy_1, DisposableBase_1, dispose_1, EventDispatcherEntry_1, extends_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    // noinspection JSUnusedLocalSymbols\n    var __extends = extends_1.default;\n    var DISPOSING = 'disposing', DISPOSED = 'disposed';\n    function entryFinalizer() {\n        //@ts-ignore\n        var _ = this;\n        var p = _.params;\n        var d = p && p.dispatcher;\n        if (d) {\n            d.removeEntry(_);\n            p.dispatcher = null;\n        }\n    }\n    var NAME = \"EventDispatcherBase\";\n    var EventDispatcherBase = /** @class */ (function (_super) {\n        __extends(EventDispatcherBase, _super);\n        function EventDispatcherBase() {\n            var _this = _super.call(this) || this;\n            // When dispatching events, we need a way to prevent recursion when disposing.\n            _this._isDisposing = false;\n            _this._disposableObjectName = NAME;\n            return _this;\n        }\n        EventDispatcherBase.prototype.addEventListener = function (type, listener, priority) {\n            if (priority === void 0) { priority = 0; }\n            var e = this._entries;\n            if (!e)\n                this._entries = e = [];\n            // flash/vibe.js means of adding is indiscriminate and will double add listeners...\n            // we can then avoid double adds by including a 'registerEventListener' method.\n            e.push(new EventDispatcherEntry_1.EventDispatcherEntry(type, listener, {\n                priority: priority || 0,\n                dispatcher: this\n            }, entryFinalizer));\n        };\n        EventDispatcherBase.prototype.removeEntry = function (entry) {\n            return !!this._entries && AU.remove(this._entries, entry) != 0;\n        };\n        // Allow for simple add once mechanism.\n        EventDispatcherBase.prototype.registerEventListener = function (type, listener, priority) {\n            if (priority === void 0) { priority = 0; }\n            if (!this.hasEventListener(type, listener))\n                this.addEventListener(type, listener, priority);\n        };\n        EventDispatcherBase.prototype.hasEventListener = function (type, listener) {\n            var e = this._entries;\n            return e && e.some(function (value) {\n                return type == value.type && (!listener || listener == value.listener);\n            }) || false;\n        };\n        EventDispatcherBase.prototype.removeEventListener = function (type, listener) {\n            var e = this._entries;\n            if (e)\n                dispose_1.dispose.these.noCopy(e.filter(function (entry) { return entry.matches(type, listener); }));\n        };\n        EventDispatcherBase.prototype.dispatchEvent = function (e, params) {\n            var _this = this;\n            var _ = this;\n            var l = _._entries;\n            if (!l || !l.length)\n                return false;\n            var event;\n            if (typeof e == 'string') {\n                event = (Event && Object.create(Event) || {});\n                if (!params)\n                    params = {};\n                if (params['cancellable'])\n                    event.cancellable = true;\n                event.target = _;\n                event.type = e;\n            }\n            else\n                event = e;\n            var type = event.type;\n            // noinspection JSMismatchedCollectionQueryUpdate\n            var entries = l.filter(function (e) { return e.type == type; }); //, propagate = true, prevent = false;\n            if (!entries.length)\n                return false;\n            entries.sort(function (a, b) {\n                return (b.params ? b.params.priority : 0)\n                    - (a.params ? a.params.priority : 0);\n            });\n            // For now... Just use simple...\n            entries.forEach(function (entry) {\n                var newEvent = Object.create(Event);\n                shallowCopy_1.shallowCopy(event, newEvent);\n                newEvent.target = _this;\n                entry.dispatch(newEvent);\n            });\n            return true;\n        };\n        Object.defineProperty(EventDispatcherBase, \"DISPOSING\", {\n            get: function () { return DISPOSING; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(EventDispatcherBase, \"DISPOSED\", {\n            get: function () { return DISPOSED; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(EventDispatcherBase.prototype, \"isDisposing\", {\n            get: function () {\n                return this._isDisposing;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // Override the public method here since EventDispatcher will end up doing things a bit differently from here on.\n        EventDispatcherBase.prototype.dispose = function () {\n            // Having a disposing event can allow for child objects to automatically release themselves when their parent is disposed.\n            var _ = this;\n            if (!_.wasDisposed && !_._isDisposing) {\n                _._isDisposing = true;\n                _.dispatchEvent(DISPOSING);\n                _super.prototype.dispose.call(this);\n                _.dispatchEvent(DISPOSED);\n                var l = _._entries;\n                if (l) {\n                    this._entries = null;\n                    l.forEach(function (e) { return e.dispose(); });\n                }\n            }\n        };\n        return EventDispatcherBase;\n    }(DisposableBase_1.DisposableBase));\n    exports.default = EventDispatcherBase;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport * as AU from \"../Collections/Array/Utility\";\r\nimport {shallowCopy} from \"../Utility/shallowCopy\";\r\nimport {DisposableBase} from \"../Disposable/DisposableBase\";\r\nimport {dispose} from \"../Disposable/dispose\";\r\nimport {IEventListener} from \"./IEventListener\";\r\nimport {EventDispatcherEntry} from \"./EventDispatcherEntry\";\r\nimport {IEventDispatcher} from \"./IEventDispatcher\";\r\nimport __extendsImport from \"../../extends\";\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\nconst DISPOSING:string = 'disposing',\r\n      DISPOSED:string  = 'disposed';\r\n\r\n// The following interfaces are exported for sub class implementation.\r\n\r\nexport interface IEventBase<TTarget>\r\n{\r\n\ttype:string;\r\n\ttarget:TTarget;\r\n}\r\n\r\nexport interface IEvent extends IEventBase<any>\r\n{\r\n\r\n}\r\n\r\nexport interface IEntryParams\r\n{\r\n\tpriority:number;\r\n\tdispatcher:EventDispatcherBase;\r\n}\r\n\r\nfunction entryFinalizer()\r\n{\r\n\t//@ts-ignore\r\n\tconst _:EventDispatcherEntry<IEntryParams> = <any>this;\r\n\tconst p = _.params;\r\n\tconst d = p && p.dispatcher;\r\n\tif(d)\r\n\t{\r\n\t\td.removeEntry(_);\r\n\t\t(<any>p).dispatcher = null;\r\n\t}\r\n}\r\n\r\nconst NAME = \"EventDispatcherBase\";\r\n\r\nexport default\r\nclass EventDispatcherBase extends DisposableBase implements IEventDispatcher\r\n{\r\n\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis._disposableObjectName = NAME;\r\n\t}\r\n\r\n\tprotected _entries:EventDispatcherEntry<IEntryParams>[]|undefined;\r\n\r\n\taddEventListener(\r\n\t\ttype:string,\r\n\t\tlistener:IEventListener,\r\n\t\tpriority:number = 0):void\r\n\t{\r\n\t\tlet e = this._entries;\r\n\t\tif(!e) this._entries = e = [];\r\n\r\n\t\t// flash/vibe.js means of adding is indiscriminate and will double add listeners...\r\n\t\t// we can then avoid double adds by including a 'registerEventListener' method.\r\n\t\te.push(\r\n\t\t\tnew EventDispatcherEntry(type, listener, {\r\n\t\t\t\t\tpriority: priority || 0,\r\n\t\t\t\t\tdispatcher: this\r\n\t\t\t\t},\r\n\t\t\t\tentryFinalizer));\r\n\t}\r\n\r\n\tremoveEntry(entry:EventDispatcherEntry<IEntryParams>):boolean\r\n\t{\r\n\t\treturn !!this._entries && AU.remove(this._entries, entry)!=0;\r\n\t}\r\n\r\n\t// Allow for simple add once mechanism.\r\n\tregisterEventListener(\r\n\t\ttype:string,\r\n\t\tlistener:IEventListener,\r\n\t\tpriority:number = 0):void//, useWeakReference: boolean= false)\r\n\t{\r\n\t\tif(!this.hasEventListener(type, listener))\r\n\t\t\tthis.addEventListener(type, listener, priority);\r\n\t}\r\n\r\n\thasEventListener(type:string, listener?:IEventListener):boolean\r\n\t{\r\n\t\tconst e = this._entries;\r\n\t\treturn e && e.some(\r\n\t\t\t\t(value:EventDispatcherEntry<IEntryParams>):boolean =>\r\n\t\t\t\ttype==value.type && (!listener || listener==value.listener)\r\n\t\t\t) || false;\r\n\t}\r\n\r\n\tremoveEventListener(\r\n\t\ttype:string,\r\n\t\tlistener:IEventListener):void\r\n\t{\r\n\t\tconst e = this._entries;\r\n\t\tif(e) dispose.these.noCopy(e.filter(entry=> entry.matches(type, listener)));\r\n\t}\r\n\r\n\tdispatchEvent(type:string, params?:any):boolean;\r\n\tdispatchEvent(event:IEvent):boolean;\r\n\tdispatchEvent(e:any, params?:any):boolean\r\n\t{\r\n\r\n\t\tconst _ = this;\r\n\r\n\r\n\t\tlet l = _._entries;\r\n\t\tif(!l || !l.length)\r\n\t\t\treturn false;\r\n\r\n\t\tlet event:IEventBase<any>;\r\n\r\n\t\tif(typeof e=='string')\r\n\t\t{\r\n\t\t\tevent = <any>(Event && Object.create(Event) || {});\r\n\t\t\tif(!params)\r\n\t\t\t\tparams = {};\r\n\t\t\tif(params['cancellable'])\r\n\t\t\t\t(<any>event).cancellable = true;\r\n\t\t\tevent.target = _;\r\n\t\t\tevent.type = e;\r\n\t\t}\r\n\t\telse\r\n\t\t\tevent = e;\r\n\r\n\t\tconst type = event.type;\r\n\r\n\t\t// noinspection JSMismatchedCollectionQueryUpdate\r\n\t\tconst entries:EventDispatcherEntry<IEntryParams>[] = l.filter(e => e.type==type);//, propagate = true, prevent = false;\r\n\t\tif(!entries.length)\r\n\t\t\treturn false;\r\n\r\n\t\tentries.sort((a, b)=>\r\n\t\t\t(b.params ? b.params.priority : 0)\r\n\t\t\t- (a.params ? a.params.priority : 0)\r\n\t\t);\r\n\r\n\t\t// For now... Just use simple...\r\n\t\tentries.forEach(\r\n\t\t\tentry=>\r\n\t\t\t{\r\n\t\t\t\tconst newEvent:any = Object.create(Event);\r\n\t\t\t\tshallowCopy(event, newEvent);\r\n\t\t\t\tnewEvent.target = this;\r\n\t\t\t\tentry.dispatch(newEvent);\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\tstatic get DISPOSING() { return DISPOSING; }\r\n\r\n\tstatic get DISPOSED() { return DISPOSED; }\r\n\r\n\t// When dispatching events, we need a way to prevent recursion when disposing.\r\n\tprivate _isDisposing:boolean = false;\r\n\tget isDisposing():boolean\r\n\t{\r\n\t\treturn this._isDisposing;\r\n\t}\r\n\r\n\t// Override the public method here since EventDispatcher will end up doing things a bit differently from here on.\r\n\tpublic dispose()\r\n\t{\r\n\r\n\t\t// Having a disposing event can allow for child objects to automatically release themselves when their parent is disposed.\r\n\t\tconst _ = this;\r\n\t\tif(!_.wasDisposed && !_._isDisposing)\r\n\t\t{\r\n\t\t\t_._isDisposing = true;\r\n\t\t\t_.dispatchEvent(DISPOSING);\r\n\r\n\t\t\tsuper.dispose();\r\n\r\n\t\t\t_.dispatchEvent(DISPOSED);\r\n\r\n\t\t\tconst l = _._entries;\r\n\t\t\tif(l)\r\n\t\t\t{\r\n\t\t\t\tthis._entries = <any>null;\r\n\t\t\t\tl.forEach(e=> e.dispose());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n}\r\n\r\n"]}