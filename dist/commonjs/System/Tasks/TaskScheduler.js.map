{"version":3,"sources":["System/Tasks/TaskScheduler.ts"],"names":["flush","runSingle","requestFlush","TaskScheduler","TaskScheduler.defer","TaskScheduler.runAfterDeferred"],"mappings":"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","file":"System/Tasks/TaskScheduler.js","sourcesContent":["/*\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n * Based on code from: https://github.com/kriskowal/q\r\n */\r\n\r\nimport Type from '../Types';\r\nimport LinkedList from \"../Collections/LinkedList\";\r\nimport Queue from \"../Collections/Queue\";\r\n\r\ndeclare module process\r\n{\r\n\texport function nextTick(callback:Function):void;\r\n\texport function toString():string;\r\n}\r\n\r\ninterface IDomain\r\n{\r\n\tenter():void;\r\n\texit():void;\r\n}\r\n\r\ninterface TaskQueueEntry\r\n{\r\n\ttask:Function;\r\n\tdomain?:IDomain;\r\n}\r\n\r\n\r\n\"use strict\";\r\n\r\nvar requestTick:()=>void;\r\nvar isNodeJS:boolean = false;\r\nvar flushing:boolean = false;\r\n\r\n// Use the fastest possible means to execute a task in a future turn\r\n// of the event loop.\r\n\r\n\r\n\r\nfunction flush():void\r\n{\r\n\t/* jshint loopfunc: true */\r\n\tvar entry:ILinkedListNode<TaskQueueEntry>;\r\n\r\n\twhile(entry = immediateQueue.first)\r\n\t{\r\n\t\tlet e = entry.value, domain = e.domain;\r\n\t\tentry.remove();\r\n\t\tif(domain) domain.enter();\r\n\t\trunSingle(e.task, domain);\r\n\t}\r\n\r\n\tvar task:Function;\r\n\twhile(task = laterQueue.dequeue())\r\n\t{\r\n\t\trunSingle(task);\r\n\t}\r\n\r\n\tflushing = false;\r\n}\r\n\r\n\r\n// linked list of tasks.  Using a real linked list to allow for removal.\r\nvar immediateQueue:LinkedList<TaskQueueEntry> = new LinkedList<TaskQueueEntry>();\r\n\r\n// queue for late tasks, used by unhandled rejection tracking\r\nvar laterQueue:Queue<Function> = new Queue<Function>();\r\n\r\nfunction runSingle(task:Function, domain?:IDomain):void\r\n{\r\n\ttry\r\n\t{\r\n\t\ttask();\r\n\r\n\t}\r\n\tcatch(e)\r\n\t{\r\n\t\tif(isNodeJS)\r\n\t\t{\r\n\t\t\t// In node, uncaught exceptions are considered fatal errors.\r\n\t\t\t// Re-throw them synchronously to interrupt flushing!\r\n\r\n\t\t\t// Ensure continuation if the uncaught exception is suppressed\r\n\t\t\t// listening \"uncaughtException\" events (as domains does).\r\n\t\t\t// Continue in next event to avoid tick recursion.\r\n\t\t\tif(domain)\r\n\t\t\t{\r\n\t\t\t\tdomain.exit();\r\n\t\t\t}\r\n\t\t\tsetTimeout(flush, 0);\r\n\t\t\tif(domain)\r\n\t\t\t{\r\n\t\t\t\tdomain.enter();\r\n\t\t\t}\r\n\r\n\t\t\tthrow e;\r\n\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// In browsers, uncaught exceptions are not fatal.\r\n\t\t\t// Re-throw them asynchronously to avoid slow-downs.\r\n\t\t\tsetTimeout(()=>\r\n\t\t\t{\r\n\t\t\t\tthrow e;\r\n\t\t\t}, 0);\r\n\t\t}\r\n\t}\r\n\r\n\tif(domain)\r\n\t{\r\n\t\tdomain.exit();\r\n\t}\r\n}\r\n\r\nfunction requestFlush():void {\r\n\tif(!flushing)\r\n\t{\r\n\t\tflushing = true;\r\n\t\trequestTick();\r\n\t}\r\n}\r\n\r\nmodule TaskScheduler {\r\n\r\n\r\n\texport function defer(task:Function, delay?:number):()=>boolean\r\n\t{\r\n\t\tif(Type.isNumber(delay,false) && delay>=0) {\r\n\r\n\t\t\tvar timeout:number = 0;\r\n\r\n\t\t\tvar cancel = ()=>{\r\n\t\t\t\tif(timeout) {\r\n\t\t\t\t\tclearTimeout(timeout);\r\n\t\t\t\t\ttimeout = 0;\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\treturn false;\r\n\t\t\t};\r\n\r\n\t\t\ttimeout = setTimeout(()=>{\r\n\t\t\t\tcancel();\r\n\t\t\t\ttask();\r\n\t\t\t},delay);\r\n\r\n\t\t\treturn cancel;\r\n\t\t}\r\n\r\n\t\tvar entry = {\r\n\t\t\ttask:task,\r\n\t\t\tdomain:isNodeJS && (<any>process)['domain']\r\n\t\t};\r\n\r\n\t\timmediateQueue.add(entry);\r\n\r\n\t\trequestFlush();\r\n\r\n\t\treturn ()=>!!immediateQueue.remove(entry)\r\n\t}\r\n\r\n\r\n\t// runs a task after all other tasks have been run\r\n\t// this is useful for unhandled rejection tracking that needs to happen\r\n\t// after all `then`d tasks have been run.\r\n\texport function runAfterDeferred(task:Function):void\r\n\t{\r\n\t\tlaterQueue.enqueue(task);\r\n\t\trequestFlush();\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nif(Type.isObject(process)\r\n\t&& process.toString()===\"[object process]\"\r\n\t&& process.nextTick)\r\n{\r\n\t// Ensure Q is in a real Node environment, with a `process.nextTick`.\r\n\t// To see through fake Node environments:\r\n\t// * Mocha test runner - exposes a `process` global without a `nextTick`\r\n\t// * Browserify - exposes a `process.nexTick` function that uses\r\n\t//   `setTimeout`. In this case `setImmediate` is preferred because\r\n\t//    it is faster. Browserify's `process.toString()` yields\r\n\t//   \"[object Object]\", while in a real Node environment\r\n\t//   `process.nextTick()` yields \"[object process]\".\r\n\tisNodeJS = true;\r\n\r\n\trequestTick = ()=>\r\n\t{\r\n\t\tprocess.nextTick(flush);\r\n\t};\r\n\r\n}\r\nelse if(typeof setImmediate===\"function\")\r\n{\r\n\t// In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\r\n\tif(typeof window!==\"undefined\")\r\n\t{\r\n\t\trequestTick = setImmediate.bind(window, flush);\r\n\t}\r\n\telse\r\n\t{\r\n\t\trequestTick = ()=>\r\n\t\t{\r\n\t\t\tsetImmediate(flush);\r\n\t\t};\r\n\t}\r\n\r\n}\r\nelse if(typeof MessageChannel!==\"undefined\")\r\n{\r\n\t// modern browsers\r\n\t// http://www.nonblocking.io/2011/06/windownexttick.html\r\n\tvar channel = new MessageChannel();\r\n\t// At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\r\n\t// working message ports the first time a page loads.\r\n\tchannel.port1.onmessage = function()\r\n\t{\r\n\t\trequestTick = requestPortTick;\r\n\t\tchannel.port1.onmessage = flush;\r\n\t\tflush();\r\n\t};\r\n\tvar requestPortTick = ()=>\r\n\t{\r\n\t\t// Opera requires us to provide a message payload, regardless of\r\n\t\t// whether we use it.\r\n\t\tchannel.port2.postMessage(0);\r\n\t};\r\n\trequestTick = ()=>\r\n\t{\r\n\t\tsetTimeout(flush, 0);\r\n\t\trequestPortTick();\r\n\t};\r\n\r\n}\r\nelse\r\n{\r\n\t// old browsers\r\n\trequestTick = ()=>\r\n\t{\r\n\t\tsetTimeout(flush, 0);\r\n\t};\r\n}\r\n\r\nexport default TaskScheduler;\r\n"]}